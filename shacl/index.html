<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL) <u></u>nofficial Japanese Version</title>
		<meta charset="utf-8">
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }

			td {
				vertical-align: top;
			}

			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}

			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}

			.def-sparql {
			}

			.def-text {
			}

			.def-text-body {
				margin-left: 2em;
			}

			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}

			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.component-class {
				font-weight: bold;
				font-size: 16px;
			}

			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}

			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}

			.term {
				font-style: italic;
			}

			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}

			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}

			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #aca; }
			pre.example-results:before { color: #797; content: "Example validation results"; width: 13em; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em;
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>
			<div class="head" role="contentinfo" id="respecHeader">
  		<h1>Shapes Constraint Language (SHACL) Unofficial Japanese Version</h1>
			<p>Shapes Constraint Language (SHACL) の非公式日本語バーションです．</p>
  		<h2>Based on W3C Editor's Draft 26 June 2016 version</h2>
			<p>W3C Editor's Draft 26 June 2016 versionをもとにしています．</p>
  		<hr title="Separator for header">
		</div>

		<section id="abstract">
			<p>
				<!-- SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of RDF graphs. -->
				SHACL (Shapes Constraint Language) は，RDFグラフの制約を表現し，制約するための言語である．
				<!-- SHACL groups these descriptions and constraints into "shapes", which specify conditions that apply at a given RDF node. -->
				SHACLは，これらの表現と制約を，指定されたRDFノードに適用する状態を特定する"シェイプ"の中にまとめる．
				<!-- Shapes provide a high-level vocabulary to identify predicates and their associated cardinalities, datatypes and other constraints. -->
				シェイプは，述語やほかの関係，データの型と制約を特定する，高レベルの語彙を提供する．
				<!-- Additional constraints can be associated with shapes using SPARQL. -->
				追加の制約は，SPARQLを使ったシェイプを関連付けられることができる．
				<!-- The vocabulary of SHACL has been designed to support similar extension languages besides SPARQL. -->
				SHACLの語彙は，SPARQLの他に，同じような拡張言語をサポートするよう定義されてきた．
				<!-- These extension languages can also be used to define new high-level vocabulary terms. -->
				これらの拡張言語も新しい高レベルの語彙を定義するのに用いることができる．
				<!-- SHACL shapes can be used to communicate information about data structures associated with some process or interface, generate or validate data, or drive user interfaces. -->
				SHACL シェイプは，いくつかのプロセスまたは，インターフェイスに関連付けられた構造についての情報をやり取りするためや，データを生成，検証するためため，ユーザインターフェイスを扱うために使うことができる．
				<!-- This document defines the SHACL language and its underlying semantics. -->
				このドキュメントはSHACL言語とそのにある意味を定義している.
			</p>
		</section>

		<section id="sotd">
		</section>

		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				This document specifies SHACL (Shapes Constraint Language), a language for describing and constraining RDF graphs.
				This section introduces SHACL with an overview of the key terminology and an example to illustrate basic concepts.
			</p>
			<section id="terminology">
				<h3>Terminology</h3>
				<p>
					Throughout this document, the following terminology is used.
				</p>
				<div class="def" id="rdf-terminology">
					<div class="term-def-header">Basic RDF Terminology</div>
					<div>
						This document uses the terms
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph"><dfn data-lt="graph|graphs|RDF graphs">RDF graph</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple"><dfn data-lt="triple|triples">RDF triple</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri"><dfn data-lt="IRI|IRIs">IRI</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal"><dfn data-lt="literal|literals">literal</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node"><dfn data-lt="blank node|blank nodes">blank node</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-node"><dfn data-lt="node|nodes">node</dfn></a> of an RDF graph,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term"><dfn>RDF term</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-subject"><dfn data-lt="subject|subjects">subject</dfn></a>,
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-predicate"><dfn data-lt="predicate|predicates">predicate</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-object"><dfn data-lt="object|objects">object</dfn></a> of RDF triples
						as defined in RDF 1.1 Concepts and Abstract Syntax [[!rdf11-concepts]].
						SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
						SHACL makes no assumptions about whether a graph contains triples that are entailed from the graph under any RDF entailment regime.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Property Values</div>
					<div>
						The <dfn data-lt="value|property value|property values">values</dfn> of (or for) a property <code>p</code> for a <a>node</a> <code>n</code> in an <a>RDF graph</a> are the
						<a>objects</a> of the <a>triples</a> in the <a>graph</a> that have <code>n</code> as <a>subject</a> and <code>p</code> as <a>predicate</a>.
						The <dfn data-lt="inverse value|inverse property value|inverse property values">inverse values</dfn> of (or for) a property <code>p</code> for a <a>node</a> <code>n</code>
						in an <a>RDF graph</a> are the <a>subjects</a> of the <a>triples</a> in the <a>graph</a> that have <code>n</code> as <a>object</a> and <code>p</code> as <a>predicate</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Subclass, SHACL superclass</div>
					<div>
						A <a>node</a> <code>Sub</code> in an <a>RDF graph</a> is a <dfn data-lt="subclasses|subclass|SHACL subclasses">SHACL subclass</dfn> of another <a>node</a> <code>Super</code>
						in the <a>graph</a> if there is a sequence of <a>triples</a> in the <a>graph</a> each with predicate <code>rdfs:subClassOf</code> such that the <a>subject</a> of the first <a>triple</a> is <code>Sub</code>,
						the <a>object</a> of the last triple is <code>Super</code>, and the <a>object</a> of each <a>triple</a> except the last is the <a>subject</a> of the next.
						If <code>Sub</code> is a <a>SHACL subclass</a> of <code>Super</code> in an <a>RDF graph</a> then <code>Super</code>
						is a <dfn data-lt="superclass|superclasses|SHACL superclasses|">SHACL superclass</dfn> of <code>Sub</code> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Type</div>
					<div>
						The <dfn data-lt="type|types|SHACL type">SHACL types</dfn> of a <a>node</a> in an <a>RDF graph</a> are its <a>values</a> for <code>rdf:type</code> in the
						<a>graph</a> as well as the <a>SHACL superclasses</a> of these <a>values</a> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Class</div>
					<div>
						<a>Nodes</a> in an <a>RDF graph</a> that might be subclasses, superclasses, or types of <a>nodes</a> in the <a>graph</a> are often referred to as <dfn data-lt="class|classes|SHACL classes">SHACL class</dfn>.
						SHACL makes no assumption whether a SHACL class has any particular <a>value</a> for <code>rdf:type</code> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Instance</div>
					<div>
						A <a>node</a> in an <a>RDF graph</a> is a <dfn data-lt="SHACL instance|SHACL instances">SHACL instance</dfn> of a <a>SHACL class</a> in the <a>graph</a>
						if one of its <a>SHACL types</a> is the given <a>class</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Data Graph, Shapes Graph, Validation, Report, Result, Violation, Failure</div>
					<div>
						SHACL defines what it means for an <a>RDF graph</a>, referred to as the <dfn data-lt="data graphs">data graph</dfn>,
						to <dfn data-lt="validation|validates|validated">validate</dfn> against an <a>RDF graph</a> containing <a>shapes</a>, referred to as the <dfn data-lt="shapes graphs">shapes graph</dfn>.
						The result of validation is a <dfn data-lt="validation report|report">validation report</dfn> including
						<dfn data-lt="validation result|result">validation results</dfn> such as informational results, warnings and violations.
						Validation may also result in a <dfn>failure</dfn>.
						Validation of a <a>shapes graph</a> against a <a>data graph</a> involves validating each <a>shape</a> in the <a>shapes graph</a> against the <a>data graph</a>.
						A <a>node</a> in a <a>data graph</a> is said to validate against a <a>shape</a> if validation of that <a>node</a>
						against the <a>shape</a> neither produces any <a>validation results</a> that are violations nor results in a <a>failure</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Shape</div>
					<div>
						A <dfn data-lt="shape|shapes">shape</dfn> is a <a>node</a> in a <a>shapes graph</a> that is a <a>SHACL instance</a> of <code>sh:Shape</code>.
						A shape provides a collection of <a>scopes</a>, <a>filters</a>, and <a>constraints</a> that specify how a <a>data graph</a> is
						validated against the shape.
						Shapes can also provide non-validating information, such as labels and names.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Scope</div>
					<div>
						A <dfn data-lt="scope|scopes">scope</dfn> is a <a>triple</a> or a <a>node</a> in the <a>shapes graph</a>
						that specifies which <a>nodes</a> in a <a>data graph</a> are considered in-scope for a <a>shape</a>.
						Validating a <a>shape</a> in a <a>shapes graph</a> involves validating the in-scope nodes for all scopes of the shape.
						SHACL provides several different kinds of scopes, most notably all <a>SHACL instances</a> in the <a>data graph</a> of a node in the <a>data graph</a>
						or a given <a>node</a> in the <a>data graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Focus Node</div>
					<div>
						A <a>node</a> in the <a>data graph</a> that is validated against a <a>shape</a> is called a <dfn data-lt="focus node|focus nodes">focus node</dfn>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Filter</div>
					<div>
						A <dfn data-lt="filter shape|filter shapes|filters">filter</dfn> is a <a>shape</a> in a <a>shapes graph</a> that limits the <a>nodes</a> that are
						validated against the constraints of another shape.
						Only those <a>nodes</a> that validate against all the filters of a shape are validated against its constraints.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint</div>
					<div>
						A <dfn data-lt="constraint|constraints">constraint</dfn> is a <a>node</a> in the <a>shapes graph</a> that determines how to validate
						<a>focus nodes</a> based on the <a>values</a> of properties of the <a>node</a>.
						Constraints can, for example, require that a focus node be an IRI or that a focus node has a particular value for a property and also a minimum number of values for the property.
						Constraints that are about a particular property and its <a>values</a> for the focus node are called <dfn data-lt="property constraint">property constraints</dfn>.
						Constraints that are about a particular property and its <a>inverse values</a> for the focus node are called <dfn data-lt="inverse property constraint">inverse property constraints</dfn>.
						Constraints that are about the <a>focus node</a> in general are called <dfn data-lt="node constraint">node constraints</dfn>.
						Constraints can also have <dfn data-lt="non-validating property">non-validating properties</dfn> (such as names and default values) that do not lead to <a>validation results</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint Component, Parameter</div>
					<div>
						A <dfn data-lt="constraint component|constraint components|components|component">constraint component</dfn> represents a part of a <a>constraint</a> that is determined
						by the <a>values</a> one or more properties.
						These properties are called <dfn data-lt="parameter">parameters</dfn>.
						For example, <code>sh:minCount</code> is a parameter for the component that checks whether the <a>focus node</a> has at least a minimum number of <a>values</a> for a
						particular property.
						Validating a <a>node</a> against a <a>constraint</a> involves validating the node against each of its <a>components</a>.
					</div>
				</div>

			</section>

			<section id="conventions">
				<h3>Document Conventions</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</table>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> SHOULD include the <code>#</code>.
				</p>
				<p>
					Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
					These fragments of Turtle documents use the prefix bindings given above.
				</p>
				<pre class="example-shapes">
# This box represents an input shapes graph

# Triples that can be ommitted are marked as grey e.g.
<span class="triple-can-be-skipped">&lt;s&gt; &lt;p&gt; &lt;o&gt; .</span></pre>

				<pre class="example-data">
# This box represents an input data graph.
# When highlighting is used in the examples:

# Elements highlighted in blue are <a>focus nodes</a> that are
# selected by some <a>scope</a> of a <a>shape</a> under discussion
# and validate against the shape's <a>filters</a>, if any.
<span class="focus-node-selected">ex:Bob</span> a ex:Person .

# Elements highlighted in red are focus nodes that fail <a href="#validation">validation</a>
<span class="focus-node-error">ex:Alice</span> a ex:Person .</pre>

				<pre class="example-results">
# This box represents an output results graph</pre>

				<p>
					SHACL Definitions appear in blue boxes:
				</p>
				<div class="def def-sparql">
					<div class="def-header">SPARQL or TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains SPARQL or textual definitions. </pre>
				</div>

			</section>

			<section>
				<h3>SHACL Example</h3>
				<p>
					The following example <a>data graph</a> contains three <a>nodes</a> that are <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
				</p>
				<pre class="example-data">
ex:Alice
	a ex:Person ;
	ex:child ex:Calvin ;
	ex:ssn "987-65-432A" .

ex:Bob
	a ex:Person ;
	ex:child ex:Calvin ;
	ex:ssn "123-45-6789" ;
	ex:ssn "124-35-6789" .

ex:Calvin
	a ex:Person ;
	ex:school ex:TrinityAnglicanSchool .</pre>
				<p>
					This example uses SHACL to define the following <a>constraints</a>:
				<p>
				<ul>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may have at most one <a>value</a> for the property <code>ex:ssn</code>,
						and this <a>value</a> must be a <a>literal</a> with the datatype <code>xsd:string</code> that matches
						a specified regular expression.
					</li>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may have unlimited <a>values</a> for the property <code>ex:child</code>,
						and these <a>values</a> must be <a>IRIs</a> and they must be <a>SHACL instances</a> of <code>ex:Person</code>.
					</li>
					<li>
						A person's parents are represented using the property <code>ex:child</code> in the inverse direction.
						A <a>SHACL instance</a> of <code>ex:Person</code> may have at most 2 parents, i.e. may be the <a>object</a> of at most two <a>triples</a>
						where the <a>predicate</a> is <code>ex:child</code>.
					</li>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may not have <a>values</a> for any other property apart from
						<code>ex:ssn</code>, <code>ex:child</code> and <code>rdf:type</code>.
					</li>
				</ul>
				<p>
					The <a>constraints</a> above can be represented using the following <a>shapes graph</a>:
				</p>
				<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;    # Applies to all persons
	sh:property [
		sh:predicate ex:ssn ;
		sh:maxCount 1 ;
		sh:datatype xsd:string ;
		sh:pattern "^\\d{3}-\\d{2}-\\d{4}$" ;
	] ;
	sh:property [
		sh:predicate ex:child ;
		sh:class ex:Person ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:inverseProperty [
		rdfs:comment "A person's parents are represented via ex:child used in the inverse direction." ;
		sh:predicate ex:child ;
		sh:name "parent" ;
		sh:maxCount 2 ;
	] ;
	sh:constraint [
		sh:closed true ;
		sh:ignoredProperties ( rdf:type ) ;
	] .</pre>
				<p>
					We can use the shape definition above to skim through some of the key terminology used by SHACL.
					The <a>focus nodes</a> for the <a>shape</a> <code>ex:PersonShape</code> are all <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
					These <a>focus nodes</a> are the <a>scope</a> of the <a>shape</a> and are defined using the property <code>sh:scopeClass</code>.
					The <a>shape</a> has two <a>property constraints</a>, linked to the shape using the property <code>sh:property</code>,
					one <a>inverse property constraint</a> represented as value of <code>sh:inverseProperty</code>,
					and one <a>node constraint</a> linked to the shape using <code>sh:constraint</code>.
				</p>
				<p>
					Some of the <a>constraints</a> specify multiple <a>constraint components</a> in order to
					restrict multiple aspects of the <a>property values</a>.
					For example, in the <a>property constraint</a> for <code>ex:ssn</code>, three <a>constraint components</a> are used.
					These <a>constraint components</a> are identified by their <a>parameters</a> <code>sh:datatype</code>, <code>sh:pattern</code> and <code>sh:maxCount</code>.
					For each <a>focus node</a>, <a>property values</a> of <code>ex:ssn</code> will be validated against all three components.
					The constraint on the inverse property values of <code>sh:child</code> has only one <a>constraint component</a> identified by the <code>sh:maxCount</code> <a>parameter</a>.
					Note that this <a>constraint</a> uses the <a>non-validating property</a> <code>sh:name</code>
					to suggest a human-readable name for the property when used in the inverse direction.
				</p>
				<p>
					SHACL <a>validation</a> based on the provided <a>data graph</a> and <a>shapes graph</a> would produce the following <a>validation results</a>:
				</p>
				<pre class="example-results">
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:RegexConstraintComponent ;
	sh:focusNode ex:Alice ;
	sh:subject ex:Alice ;
	sh:predicate ex:ssn ;
	sh:object "987-65-432A" ;
	sh:severity sh:Violation ;
] ;
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:MaxCountConstraintComponent ;
	sh:focusNode ex:Bob ;
	sh:subject ex:Bob ;
	sh:predicate ex:ssn ;
	sh:severity sh:Violation ;
] ;
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:ClosedConstraintComponent ;
	sh:focusNode ex:Calvin ;
	sh:subject ex:Calvin ;
	sh:predicate ex:school ;
	sh:object ex:TrinityAnglicanSchool ;
	sh:severity sh:Violation ;
] .</pre>
				<p>
					The first <a>validation result</a> is produced because <code>ex:Alice</code> has a <a>value</a> for <code>ex:ssn</code>
					that does not match the regular expression specified by the property <code>sh:regex</code>.
					The second <a>validation result</a> is produced because <code>ex:Bob</code> has more than the permitted number of <a>values</a>
					for the property <code>ex:ssn</code> as specified by the <code>sh:maxCount</code> of 1.
					The third <a>validation result</a> is produced because the <a>shape</a> <code>ex:PersonShape</code> has a <a>node constraint</a> using
					the property <code>sh:closed</code> but <code>ex:Calvin</code> uses the property <code>ex:school</code> which is neither one of the predicates from any of the
					<a>property constraints</a> at the shape, nor one of the properties listed using <code>sh:ignoredProperties</code>.
				</p>
			</section>

			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS inferencing</h3>
				<p>
					SHACL uses the RDF and RDFS vocabularies, but full RDFS inferencing is not required.
					However, SHACL processors MUST identify <a>SHACL instances</a> of a class both in the <a>data graph</a> and the <a>shapes graph</a> without mutating either graph during the <a href="#validation">validation process</a>.
					Furthermore, SHACL processors may operate on RDF graphs that include entailments - either pre-computed before being submitted to a SHACL processor or performed on the fly as part of SHACL processing.
					To support processing of entailments, SHACL includes the property <a href="#entailment"><code>sh:entailment</code></a> to indicate what inferencing is required by a given <a>shapes graph</a>.
					SHACL implementations may, but are not required to, support entailment regimes.
				</p>
			</section>

			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses parts of SPARQL 1.1 in the normative definition of the semantics of the SHACL Core <a>constraints</a> and <a>scopes</a>.
					However, SPARQL is not required for the implementation of the SHACL Core language.
				</p>
				<p>
					SPARQL variables using <code>$</code> marker represent external values that must be <a>pre-bound</a> in the SPARQL query before execution.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of <a>blank nodes</a>,
					so that repeated invocations of queries consistently identify and communicate the same <a>blank nodes</a>.
				</p>
				<p>
					The definition of some <a>constraints</a> requires or is simplified through access to the <a>shapes graph</a> during query execution.
					SHACL validation engines MAY <a>pre-bind</a> the variable <code>$shapesGraph</code> to provide access to the <a>shapes graph</a>.
					Access to the <a>shapes graph</a> is not a requirement for supporting the SHACL core language.
					The variable <code>$shapesGraph</code> can also be used in user-defined <a href="#sparql-constraints">SPARQL constraints</a> and <a href="#constraint-components">SPARQL-based constraint components</a>.
					However, such <a>constraints</a> may not be interoperable across different SHACL validation engines or not applicable to remote RDF datasets.
				</p>
				<p>
					Some SHACL <a>constraints</a> are defined with the use of the <a href="#hasShape"><code>sh:hasShape</code></a> function.
					SHACL additionally introduces mechanisms to define <a>constraints</a>, <a>scopes</a> and new functions in SPARQL.
					Implementations that cover only the the SHACL Core features are not required to implement these mechanisms or the <code>sh:hasShape</code> function.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form>
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>

			<section id="conformance">
				<p>
					<span class="todo">TODO: We still need to mark non-normative sections.</span>
				</p>
			</section>

		</section>

		<div style="padding-top: 30px"> <!-- ALH: really??? -->
			<h1 id="part1" style="font-size: 160%; font-weight: bold">Part 1: Core Features</h1>
		</div>

		<section id="shapes">
			<h2>Shapes</h2>
			<p>
				<a>Shapes</a> are <a>SHACL instances</a> of <code>sh:Shape</code> and define one or more <a>constraints</a> that a set of <a>focus nodes</a> can be validated against.
				The set of <a>focus nodes</a> for a <a>shape</a> may be defined explicitly in a <a>shape</a> using <a>scopes</a> and <a>filters</a>.
				The <a>focus nodes</a> may also be determined as part of the <a>validation</a> of <a>constraints</a> that include references to <a>shapes</a>
				using properties such as <a href="#ShapeConstraintComponent"><code>sh:shape</code></a> and <a href="#OrConstraintComponent"><code>sh:or</code></a>.
				<!--Shape scopes define the selection criteria for the in-scope nodes.
				Shapes with scopes MAY additionally provide <a>filters</a>.
				Filter shapes further refine the focus nodes to the ones that conform to a set of filter shapes.-->

				Shapes can also provide <a href="#nonValidation">non-validating information</a>, such as labels and names.

				The following figure depicts a workflow of the scoping and filtering process.
				SHACL <a>validation</a> engines MAY alter the order of the depicted steps as long as the returned <a>validation results</a> are correct.
				<!--DK: TODO check term correct -->

			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the scoping and filtering process</figcaption>
			</figure>

			<section id="scopes">
				<h3>Scopes</h3>
				<p>
					Scopes specify which <a>nodes</a> in the <a>data graph</a> are considered in-scope for a <a>shape</a> and SHACL includes four core scope types:
					<a href="#scopeNode">node scopes</a>, <a href="#scopeClass">class-based scopes</a>, <a href="#scopeProperty">property scopes</a>, and
					<a href="#scopeInverseProperty">inverse property scopes</a>.
				</p>
				<p>
					The SHACL language additionally defines a <a href="#sparql-scopes">general scoping mechanism based on SPARQL</a>.
				</p>
				<p>
					When multiple <a>scopes</a> are provided in a <a>shape</a>, the scope of a shape is the union of all in-scope nodes produced by these scopes.
					In addition to the explicit scoping mechanism, a shape may get an implicit scope when it is mentioned from other shapes (e.g. in <a href="#constraints-shape">shape-based constraint components</a>).
					Nodes specified by scopes are not required to exist in the <a>data graph</a>.
				</p>

				<section id="scopeNode">
					<h4>Node scopes (sh:scopeNode)</h4>
					<p>
						A <dfn data-lt="node scopes">node scope</dfn> with value <code>$scopeNode</code>, defines <code>$scopeNode</code> as the <a>node</a> in-scope in the <a>data graph</a>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	BIND ($scopeNode AS ?this)
}</pre>
					</div>
					<p>
						<a>Node scopes</a> are defined with the <code>sh:scopeNode</code> predicate.
						The <a>values</a> of <code>sh:scopeNode</code> can be a <a>IRIs</a> or <a>literals</a>.
					</p>

					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeNode ex:Alice .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:Bob a ex:Person .</pre>
					<p>
						With the example data above, only <code>ex:Alice</code> is in-scope for the provided shape.
					</p>
				</section>

				<section id="scopeClass">
					<h4>Class-based Scopes (sh:scopeClass)</h4>
					<p>
						A <dfn>class scope</dfn> for class <code>$scopeClass</code> is defined as the set of all <a>SHACL instances</a> of <code>$scopeClass</code> in the <a>data graph</a>.
						<code>$scopeClass</code> must be an <a>IRI</a> that is expected to be a <a>SHACL class</a>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this rdf:type/rdfs:subClassOf* $scopeClass
}</pre>
					</div>
					<p>
						Class scopes are defined with the <code>sh:scopeClass</code> predicate.
					</p>
					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeClass ex:Person .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
<span class="focus-node-selected">ex:Bob</span> a ex:Person .
ex:NewYork a ex:Place .</pre>
					<p>
						In this example, only <code>ex:Alice</code> and <code>ex:Bob</code> are in-scope.
						Note that, according to the <a>SHACL instance</a> definition, all the <code>rdfs:subClassOf</code> declarations must exist in the <a>data graph</a>.
						However, the <code>ex:Person a rdfs:Class</code> triple is not required to exist in either graphs.
					</p>
					<p>
						In the following example, the selected in-scope node is only <code>ex:Who</code>.
					</p>
					<pre class="example-data">
ex:Doctor rdfs:subClassOf ex:Person .
<span class="focus-node-selected">ex:Who</span> a ex:Doctor .
ex:House a ex:Nephrologist .</pre>
					<section id="implicit-scopeClass">
						<h4>Implicit Class Scopes</h4>
						<p>
							When, in the <a>shapes graph</a>, a <a>shape</a> is a <a>SHACL instance</a> of both <code>sh:Shape</code> and <code>rdfs:Class</code>
							then the <a>shape</a> is a <a>class scope</a> of itself.
						</p>
						<pre class="example-shapes">
ex:Person
	<b>a rdfs:Class</b>, sh:Shape .</pre>
						<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .</pre>
						<p>
							In this example, only <code>ex:Alice</code> is in-scope, because it is a <a>SHACL instance</a> of
							<code>ex:Person</code> which is both a class and a shape in the <a>shapes graph</a>.
						</p>
					</section>
				</section>

				<section id="scopeProperty">
					<h5>Property scopes (sh:scopeProperty)</h5>
					<p>
						A <dfn>property scope</dfn> for property <code>$scopeProperty</code> is defined as the set of <a>subjects</a> in the <a>data graph</a> that appear in a <a>triple</a> with <code>$scopeProperty</code> as a <a>predicate</a>.
					</p>

					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this $scopeProperty ?any .
}</pre>
					</div>
					<p>
						A shape defines a <a>property scope</a> with the predicate <code>sh:scopeProperty</code>,
						the <a>values</a> of which must be <a>IRIs</a>.
					</p>
					<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scopeProperty ex:knows .</pre>
					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
ex:Bob ex:livesIn ex:NewYork .</pre>
					<p>
						In the example above, only <code>ex:Alice</code> is in-scope for the given shape,
						because it is the <a>subject</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
					</p>
				</section>

				<section id="scopeInverseProperty">
					<h5>Inverse property scopes (sh:scopeInverseProperty)</h5>
					<p>
						An <dfn>inverse property scope</dfn> for property <code>$scopeInverseProperty</code> is defined as the set of <a>objects</a> in the <a>data graph</a> that appear in a <a>triple</a> with <code>$scopeInverseProperty</code> as a <a>predicate</a>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?any $scopeInverseProperty ?this .
}</pre>
					</div>
					<p>
						A shape defines an <a>inverse property scope</a> with the predicate <code>sh:scopeInverseProperty</code>,
						the <a>values</a> of which must be <a>IRIs</a>.
					</p>
					<pre class="example-shapes">
ex:InversePropertyScopeExampleShape
	a sh:Shape ;
	sh:scopeInverseProperty ex:knows .</pre>
					<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn ex:NewYork .</pre>
					<p>
						In the example above, only <code>ex:Bob</code> is in-scope for the given shape,
						because it is the <a>object</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
					</p>
				</section>
			</section>

			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					A <a>filter</a> is a <a>shape</a> in a <a>shapes graph</a> that can be used to limit the in-scope nodes that are validated against the <a>constraints</a> of another shape.
					Only those nodes that validate against all the filters of a shape are validated against its constraints.
					A filter is specified with the <code>sh:filterShape</code> predicate.
					When the filter is specified in a shape, the filter applies for all the shape <a>constraints</a>.
					When the filter is specified in a specific <a>constraint</a>, the filter applies for that specific constraint only.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint on <code>ex:email</code> is filtered to include only <a>SHACL instances</a> of <code>ex:Person</code> that are <code>ex:member</code>s of <code>ex:W3c</code>.
				</p>
				<pre class="example-shapes">
ex:ExampleFilteredShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:filterShape [
		<span style="color: grey;">a sh:Shape ; # Optional triple</span>
		sh:property [
			sh:predicate ex:member ;
			sh:hasValue ex:W3c ;
		]
	] ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
	] .</pre>

<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person ;
	ex:member ex:W3c ;
	ex:email &lt;mailto:alice@example.org&gt; .
<span class="focus-node-selected">ex:John</span> a ex:Person ;
	ex:member ex:W3c .
ex:Bob a ex:Person ;
	ex:member ex:Acme .</pre>

				<pre class="example-results">
[  a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:John ;
	sh:subject ex:John ;
	sh:predicate ex:email ;
	sh:message "sh:minCount for ex:email is '1'." ;
	sh:sourceConstraintComponent sh:MinCountConstraintComponent ;
] . </pre>

				<p>
					The following example shows a <code>sh:filterShape</code> that is defined on a specific <a>constraint</a>, instead of the whole <a>shape</a>.
				</p>

				<pre class="example-shapes">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
		sh:filterShape [
			sh:property [
				sh:predicate ex:member ;
				sh:hasValue ex:W3c ;
			]
		] ;
	] .
</pre>
				<p>
					Note that filter shapes are <em>always</em> validated prior to applying their associated shape or constraint.
					This includes scenarios such as <a href="#ShapeConstraintComponent"><code>sh:shape</code></a> where a shape is explicitly referenced by another constraint.
					However, during the validation of a shape referenced via <code>sh:shape</code>, the declared <a>scopes</a> of these shapes are not used to limit the set of focus nodes.
				</p>
				<!-- span class="todo">TODO: say anything about filters and severities?</span><br/
				HK: What would that potentially be? -->
			</section>

			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					A shape defines constraints and <code>sh:Constraint</code> is the <a>SHACL superclass</a> of all constraint types.
					The SHACL core language defines the following three <span class="term">constraint types</span>:
				</p>
				<ul>
					<li>
						<code>sh:PropertyConstraint</code> is the class of constraints that specify conditions
						that must be met with respect to <a>triples</a> with the <a>focus node</a> as a <a>subject</a> and a particular property as a <a>predicate</a>.
					</li>
					<li>
						<code>sh:InversePropertyConstraint</code> is the class of constraints that specify conditions
						that must be met with respect to <a>triples</a> with the <a>focus node</a> as an <a>object</a> and a particular property as a <a>predicate</a>.
					</li>
					<li>
						<code>sh:NodeConstraint</code> is the class of constraints that specify arbitrary conditions
						that must be met with respect to the <a>focus node</a>.
					</li>
				</ul>
				<p>
					Additional types of constraints can be added using the extension mechanism,
					either <a href="#sparql-constraints">SPARQL-based constraints</a> or
					<a href="#constraint-components">SPARQL-based constraint components</a>.
				</p>
				<p>
					Shapes link to their constraints via the following properties:
				</p>
				<ul>
					<li>
						<code>sh:property</code> links shapes to <a>property constraints</a>.
						The <span class="term">default value type</span> of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
					</li>
					<li>
						<code>sh:inverseProperty</code> links shapes to <a>inverse property constraints</a>.
						The <span class="term">default value type</span> of <code>sh:inverseProperty</code> is <code>sh:InversePropertyConstraint</code>.
					</li>
					<li>
						<code>sh:constraint</code> links shapes to <a>node constraints</a>.
						The <span class="term">default value type</span> of <code>sh:constraint</code> is <code>sh:NodeConstraint</code>.
					</li>
				</ul>
				<p>
					The values of <code>sh:property</code>, <code>sh:inverseProperty</code>, and <code>sh:constraint</code> must be <a>IRIs</a> or <a>blank nodes</a>.
					The <a>values</a> of <code>sh:property</code> and <code>sh:inverseProperty</code> must be the
					<a>subject</a> of precisely one <a>triple</a> with <a>predicate</a> <code>sh:predicate</code>,
					and the <a>object</a> of this <a>triple</a> must be an <a>IRI</a>.
				</p>
				<p class="issue" data-number="133" title="Default value type">
					The WG is still working out whether and how a concept of default value types is specified and used in SHACL.
				</p>
				<p id="default-value-types">
					All three properties have a <a href="#defaultValueType"><span class="term">default value type</span></a> and thus, the <code>rdf:type</code> triple can be omitted.
					<span class="term">Instances</span> of constraint types can be reused across different shapes.
					However, all constraint types are pairwise disjoint and no more than one property of <code>sh:property</code>, <code>sh:inverseProperty</code> and <code>sh:constraint</code> can link to the same RDF node within the same <a>shapes graph</a>.
				</p>
				<p>
					Constraints may contain
					<a href="#nonValidation">non-validating</a> properties (such as <code>sh:description</code>) or
					<a>parameters</a> of <a>constraint components</a> (e.g. <code>sh:minCount</code>).
					<a>Constraint components</a> define one or more <a>parameter</a> properties and <a>validation</a> instructions
					(such as those implemented as SPARQL queries) that can be used to perform the <a>validation</a> for the given <a>focus node</a> and parameter <a>values</a>.
					The relationship between a <a>constraint component</a> and the <span class="term">constraint types</span>
					that it can be used with is called the <dfn data-lt="contexts">context</dfn> of the component.
					For example, the <span class="term">context</span> of the component defining the <code><a href="#ClosedConstraintComponent">sh:closed</a></code> property is <code>sh:NodeConstraint</code>.
					This means that the property <code>sh:closed</code> can only be used in <a>SHACL instances</a> of <code>sh:NodeConstraint</code>.
					The catalog of constraint components in the Core of SHACL is defined in <a href="#constraints">section 4</a>.
				</p>
				<p>
					The following examples illustrate two ways of using (property) constraints.
					The first example uses a blank node:
				</p>
				<pre class="example-shapes">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:name "some property" ;
		sh:description "Description of the role of ex:someProperty (in the context of the constraint)" ;
		sh:minCount 1 ;
		sh:class ex:SomeClass ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be more easily referenced and shared across multiple shapes:
				</p>
				<pre class="example-shapes">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAlonePropertyConstraintExampleShape_someProperty .

ex:StandAlonePropertyConstraintExampleShape_someProperty
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:class ex:SomeClass .</pre>
				<p>
					Parameters of constraint components that only declare one parameter (such as <code>sh:class</code>)
					may be used multiple times within the same constraint node.
					In the following example this technique is used to restrict the values of a property to be <a>SHACL instances</a> of both
					<code>ex:Customer</code> and <code>ex:MalePerson</code>.
				</p>
				<pre class="example-shapes">
ex:ShapeWithTwoClasses
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:class ex:Customer ;
		sh:class ex:MalePerson ;
	] .</pre>
			</section>
		</section>

		<section id="validation">
			<h2>Validation and Graphs</h2>
			<p>
				A SHACL validation engine takes two immutable RDF graphs as input, a valid <a>shapes graph</a> and a
				<a>data graph</a>, and validates the <a>data graph</a> against the <a>shapes graph</a> as described herein.
			</p>

			<div id="def-validation" class="def def-text">
				<div class="def-header">VALIDATION DEFINITION</div>
				<div class="def-text-body">
					<ul>
						<li>A <a>node</a> validates against a <a>shape</a> iff
							either it does not validate against some <a>filter</a> of the shape
							or none of the <a>constraints</a> in the shape produce a <a>validation result</a> with severity <code>sh:Violation</code> for the node.
						</li>
						<li>A <a>data graph</a> validates against a <a>shape</a> iff
							each node that is in any of the <a>scopes</a> of the shape validates against the shape.
						</li>
						<li>A <a>data graph</a> validates against a <a>shapes graph</a> iff
							the data graph validates against each <a>shape</a> in the shapes graph.
						</li>
					</ul>
				</div>
			</div>

			<p>
				The validation process returns a <a>validation report</a> containing all <a>validation results</a>.
				By default, the validation report contains validation results of all <a>severity</a> levels
				but the user can request validation results with a custom minimum severity.
				According to the definition of validation, a <a>validation report</a> may contain <a>validation results</a> but as long as none is of severity <code>sh:Violation</code> the <a>data graph</a> is considered valid.
				For simpler validation scenarios, SHACL validation engines SHOULD provide an additional validation interface that returns only <span class="term">VALID</span> or <span class="term">INVALID</span>.
			<p>
				During validation, the <a>data graph</a> and the <a>shapes graph</a> must remain immutable, i.e. both graphs at the end of the validation must be identical to the graph at the beginning of validation.
			</p>
			<p>
				A SHACL validation engine MUST implement all constructs in the core of SHACL (Sections 2, 3, 4).
				A SHACL engine MAY not implement the other parts of SHACL.
				<!--  span class="todo">TODO sections 2 and 4 are implied by definition</span-->
			</p>

			<section id="shapes-graph">
				<h3>Shapes Graph</h3>
				<p>
					The <a>shapes graph</a> contains shape definitions that a <a>data graph</a> can be tested against.
					Shape definitions can be reusable validation components.
					Importing multiple shapes graphs can be achieved with the predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a>.
					SHACL validation engines SHOULD transitively follow all <a>values</a> of <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> to other graphs and use the resulting union graph as <a>shapes graph</a> to the <a>validation</a> process.
				</p>
				<p>
					In addition to shape definitions, the shapes graph may contain additional information for the validation engine such as <a href="#entailment">entailment</a> directives.
				</p>
			</section>

			<section id="data-graph">
				<h3>Data Graph</h3>
				<p>
					The <span class="term">data graph</span> contains the RDF data that a SHACL engine can <a>validate</a>.
					SHACL treats it as a general RDF graph and makes no assumption if it is e.g. an RDF dataset, an in-memory graph or a named graph in a remote SPARQL endpoint.
					<!-- TODO: say something about datasets / $shapesGraph -->
				</p>
				<p>
					The data graph SHOULD include all the ontology axioms related to the data and especially all the <code>rdfs:subClassOf</code> triples in order for SHACL to correctly identify class scopes and validate core SHACL constraints.
					If such triples are missing, the validation could report false violations or miss to report some violations.
				</p>


			</section>
			<section id="sh-shapes-graph">
				<h3>Linking to shapes graphs (sh:shapesGraph)</h3>


				<p>
					A <a>data graph</a> can include triples used to suggest one or more <a>shapes graphs</a> to a SHACL validation engine with the predicate <code>sh:shapesGraph</code>.
					Every <a>value</a> of this property is an <a>IRI</a> representing a <a>shapes graph</a> that should be used to validate the <a>data graph</a>.
					A SHACL validation engine MAY use such suggestions to determine which <a>shapes graph</a> to use for validating a <a>data graph</a>.
				</p>
				<p>
					In the following example, a tool may use the union of <code>ex:graph-shapes1</code> and <code>ex:graph-shapes2</code> graphs (and their <code>owl:imports</code>) as the <a>shapes graph</a> when validating the given graph.
				</p>

				<pre class="example-shapes">
[] sh:shapesGraph ex:graph-shapes1 ;
	sh:shapesGraph ex:graph-shapes2 .</pre>

				<section id="sh-shapes-graph-vocab">
					<h4>Vocabularies and Ontologies</h4>
					<p>
						The same mechanism applies for ontologies or vocabularies. The ontology or the vocabulary IRI can point to one or more <a>shapes graphs</a> with the predicate <code>sh:shapesGraph</code>.
						A SHACL validation engine MAY take this information into account to determine which <a>shapes graph</a> to use for validating a <a>data graph</a> that uses that ontology or vocabulary.
					</p>
				</section>
			</section>

			<section id="validation-report">
				<h3>Validation report</h3>
				<p>
					The <a>validation report</a> is the result of the validation process and includes a set of zero or more <a>validation results</a>.
					Each validation result is assigned a <dfn>severity</dfn> that can be informative, non-critical (warning) or violation.
					A validation process is considered successful when the validation report contains only informative or non-critical results.
					In addition to severities, each <a>validation results</a> contains a set of required or optional values that are described in the SHACL <span class="term">Validation Results Vocabulary</span>.
				</p>
				<p>
					The validation results produced by a SHACL validation engine MUST be the product of validation of the <a>data graph</a> only.
					Some engines MAY also report errors in the <a>shapes graph</a>, but those errors MUST NOT be mixed with the data validation results using the same results vocabulary.
				</p>

				<section id="results">
					<h4>Validation Results</h4>
					<p>
						SHACL includes an RDF vocabulary to represent <a>validation results</a> together with
						structural information that may provide guidance on how to identify or fix a violation.
					</p>

					<p>
						The following graph represents a example validation result:
					</p>
			<pre class="example-results">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:Bob ;
	sh:subject ex:Bob ;
	sh:predicate ex:age ;
	sh:object "twenty two" ;
	sh:message "ex:age expects a literal of datatype xsd:integer." ;
	sh:sourceConstraintComponent sh:DatatypeConstraintComponent .</pre>
					<p>
						Validation results must be <a>SHACL instances</a> of the class <code>sh:ValidationResult</code>.
						Its <a>SHACL superclass</a>, <code>sh:AbstractResult</code>, defines the properties described in the following sub-sections.
						SHACL implementations may produce <a>SHACL instances</a> of other <a>SHACL subclasses</a> of <code>sh:AbstractResult</code>, for example
						to report successfully completed constraint checks or accumulated results.
					</p>
					<section id="results-focus-node">
						<h5>Focus node (sh:focusNode)</h5>
						<p>
							Validation results may have a single value for the property <code>sh:focusNode</code> to point to an
							<a>IRI</a> or <a>blank node</a> that has caused the result.
							This represents the <a>focus node</a> that was validated when the validation result was produced.
						</p>
					</section>
					<section id="results-triple">
						<h5>Triple (sh:subject, sh:predicate and sh:object)</h5>
						<p>
							Validation results are often caused by a single RDF triple, or a predicate in the context of a given subject or object.
							This information can be encoded via the properties <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>,
							each of which can have at most one value.
							<code>sh:predicate</code> can only be present if either <code>sh:subject</code> or <code>sh:object</code> have also been specified.
							If <code>sh:object</code> is unspecified, then the interpretation is that the result is caused by the subject/predicate combination.
							If <code>sh:subject</code> is unspecified, then the interpretation is that the result is caused by the object/predicate combination.
						</p>
					</section>
					<section id="results-source">
						<h5>Source (sh:sourceConstraint, sh:sourceShape and sh:sourceConstraintComponent)</h5>
						<p>
							Validation results may link to one <code>sh:Constraint</code> that has caused
							the result, specified via the property <code>sh:sourceConstraint</code>,
							and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
							Validation results may link to the <a>constraint component</a> that caused the result
							via <code>sh:sourceConstraintComponent</code>.
						</p>
					</section>
					<section id="results-detail">
						<h5>Detail (sh:detail)</h5>
						<p>
							The property <code>sh:detail</code> may link a (parent) result with one or more other
							(child) results that provide further details about the cause of the (parent) result.
							Depending on the capabilities of the constraint validation engine, this may include violations of
							nested constraints that have been evaluated via <code>sh:shape</code>.
						</p>
					</section>
					<section id="results-message">
						<h5>Message (sh:message)</h5>
						<p>
							Validation results may have values for the property <code>sh:message</code> to communicate
							additional textual details to humans.
							While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
						</p>
					</section>
					<section id="results-severity">
						<h5>Severity (sh:severity)</h5>
						<p>
							Each validation result must have exactly one of the following values for the property <code>sh:severity</code>.
						</p>
						<table class="term-table">
							<tr>
								<th>Severity</th>
								<th>Description</th>
							</tr>
							<tr>
								<td><code>sh:Info</code></td>
								<td>An informative message, not a violation.</td>
							</tr>
							<tr>
								<td><code>sh:Warning</code></td>
								<td>A non-critical constraint violation indicating a warning.</td>
							</tr>
							<tr>
								<td><code>sh:Violation</code></td>
								<td>A constraint violation that should be fixed.</td>
							</tr>
						</table>
					</section>
					<section id="severity">
						<h3>Declaring the Severity of a Constraint</h3>
						<p>
							Constraints can specify their severity level using the property <code>sh:severity</code>,
							which must link to one of the severities.  <code>sh:Violation</code> is the default if unspecified.
							Constraints based on <a href="#constraint-components">constraint components</a> use the <code>sh:severity</code> declared at the component IRI unless overridden at the constraint.
							The following example clarifies this.
						</p>
				<pre class="example-shapes">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# The default severity for sh:maxCount is sh:Violation
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] .</pre>
					</section>
				</section>


			</section>
		</section>

		<section id="constraints">
			<h2>Core Constraint Components</h2>
			<p>
				The following sections define the <a>constraint components</a> built into the SHACL Core.
				Compliant SHACL <a>validation</a> engines MUST support all of these constraint components.
			</p>
			<p>
				The choice of constraint components that are defined by the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the core language manageable.
				Not all use cases (such as describing constraints on members of an <code>rdf:List</code>) can be expressed by the Core Vocabulary alone.
				Instead, SHACL provides extension mechanisms as described in the second part of this specification.
				It is expected that reusable libraries of SHACL extensions will be maintained by third parties.
			</p>
			<p>
				Note that the textual definitions of the constraint components refer to the <a href="#results">Validation Results Vocabulary</a>.
				Each constraint component is identified by an IRI that is referenced in the validation results via <code>sh:sourceConstraintComponent</code>.
				Many constraint components can be used in multiple <a>contexts</a>, e.g. both in a <a>property constraint</a> context
				and an <a>inverse property constraint</a> context.
			</p>
			<p>
				The textual description of each component refers to the concept of <dfn data-lt="value node">value nodes</dfn>
				which is defined as follows, including rules for the creation of validation results:
			</p>
			<ul>
				<li>
					For <a>property constraints</a> the <span class="term">value nodes</span> are the <a>objects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>subject</a> and the given property as <a>predicate</a>.
					Each produced <a>validation result</a> must have the <a>focus node</a> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value node as its <code>sh:object</code>.
				</li>
				<li>
					For <a>inverse property constraints</a> the <span  class="term">value nodes</span> are the <a>subjects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>object</a> and the given property as <a>predicate</a>.
					Each produced <a>validation result</a> must have the <a>focus node</a> as its <code>sh:object</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value node as its <code>sh:subject</code>.
				</li>
				<li>
					For <a>node constraints</a> the <span  class="term">value nodes</span> are the individual <a>focus nodes</a>, forming a set of exactly one node.
				</li>
			</ul>
			<p>
				The SPARQL definitions in this section may only be written for one of the three possible contexts, for brevity.
				Corresponding queries can be formulated for the other cases (such as the inverse direction) easily.
				The SPARQL definitions also assume the variable bindings and result variable mapping rules detailed in the
				<a href="#sparql-constraints">section on SPARQL-based Constraints</a>.
				In a nutshell, the variable <code>$this</code> represents the currently validated focus node.
				In <code>sh:PropertyConstraint</code>s and <code>sh:InversePropertyConstraint</code>s,
				the value of the variable <code>$predicate</code> is the value of <code>sh:predicate</code>
				in the constraint.
			</p>
			<p>
				Note that the parameter tables in each of the following sections have a column called Value Type which indicates the expected
				type of the parameter values for documentation purposes, without enforcing any formal restrictions.
			</p>
			<p>
				The SPARQL definitions in this section also assume the existence of a built-in SPARQL function <a href="#hasShape"><code>sh:hasShape</code></a>.
			</p>
			<p>
				The following table summarizes the parameters used by the core constraint components.
				The table clarifies whether these parameters can be used as part of a
				<code>sh:NodeConstraint</code> (NC, to apply to the focus node itself),
				a <code>sh:PropertyConstraint</code> (PC, to apply to all values of a given property),
				or a <code>sh:InversePropertyConstraint</code> (IPC, to apply to all inverse values of a given property).
			</p>
			<table class="term-table">
				<tr>
					<th>Parameters</th>
					<th>NC</th>
					<th>PC</th>
					<th>IPC</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td>
						<a href="#ClassConstraintComponent"><code>sh:class</code></a> and
						<a href="#ClassInConstraintComponent"><code>sh:classIn</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Type, based on <code>rdf:type</code></td>
				</tr>
				<tr>
					<td>
						<a href="#ClosedConstraintComponent"><code>sh:closed</code></a>
					</td>
					<td>&#9745;</td>
					<td></td>
					<td></td>
					<td>Only allow the declared properties</td>
				</tr>
				<tr>
					<td>
						<a href="#DatatypeConstraintComponent"><code>sh:datatype</code></a> and
						<a href="#DatatypeInConstraintComponent"><code>sh:datatypeIn</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Datatype, for literals</td>
				</tr>
				<tr>
					<td><a href="#DisjointConstraintComponent"><code>sh:disjoint</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Property without overlapping values</td>
				</tr>
				<tr>
					<td><a href="#EqualsConstraintComponent"><code>sh:equals</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Property with equal values</td>
				</tr>
				<tr>
					<td><a href="#HasValueConstraintComponent"><code>sh:hasValue</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>A specific required value</td>
				</tr>
				<tr>
					<td><a href="#InConstraintComponent"><code>sh:in</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Enumeration of allowed values</td>
				</tr>
				<tr>
					<td><a href="#LessThanConstraintComponent"><code>sh:lessThan</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Must have lesser values than another property</td>
				</tr>
				<tr>
					<td><a href="#LessThanOrEqualsConstraintComponent"><code>sh:lessThanOrEquals</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Must have lesser or equal values than another property</td>
				</tr>
				<tr>
					<td><a href="#MinCountConstraintComponent"><code>sh:minCount</code></a>, <a href="#MaxCountConstraintComponent"><code>sh:maxCount</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Minimum and maximum cardinality</td>
				</tr>
				<tr>
					<td><a href="#MinLengthConstraintComponent"><code>sh:minLength</code></a>, <a href="#MaxLengthConstraintComponent"><code>sh:maxLength</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Minimum and maximum string length</td>
				</tr>
				<tr>
					<td><a href="#MaxExclusiveConstraintComponent"><code>sh:maxExclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Maximum exclusive value (&gt;)</td>
				</tr>
				<tr>
					<td><a href="#MaxInclusiveConstraintComponent"><code>sh:maxInclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Maximum inclusive value (&gt;=)</td>
				</tr>
				<tr>
					<td><a href="#MinExclusiveConstraintComponent"><code>sh:minExclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Minimum exclusive value (&lt;)</td>
				</tr>
				<tr>
					<td><a href="#MinInclusiveConstraintComponent"><code>sh:minInclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Minimum inclusive value (&lt;=)</td>
				</tr>
				<tr>
					<td><a href="#NodeKindConstraintComponent"><code>sh:nodeKind</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Node kind (IRI, blank node, or literal)</td>
				</tr>
				<tr>
					<td>
						<a href="#NotConstraintComponent"><code>sh:not</code></a>,
						<a href="#AndConstraintComponent"><code>sh:and</code></a> and
						<a href="#OrConstraintComponent"><code>sh:or</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Logical operators on shapes</td>
				</tr>
				<tr>
					<td><a href="#PatternConstraintComponent"><code>sh:pattern</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Regular expression string matching</td>
				</tr>
				<tr>
					<td><a href="#StemConstraintComponent"><code>sh:stem</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>IRIs must start with the given string</td>
				</tr>
				<tr>
					<td><a href="#UniqueLangConstraintComponent"><code>sh:uniqueLang</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>No duplicate language tags</td>
				</tr>
				<tr>
					<td><a href="#ShapeConstraintComponent"><code>sh:shape</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Nested shape of all values</td>
				</tr>
				<tr>
					<td><a href="#QualifiedValueShapeConstraintComponent"><code>sh:qualifiedValueShape</code>, <code>sh:qualifiedMinCount</code>, <code>sh:qualifiedMaxCount</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Nested shape of a given minimum/maximum number of values</td>
				</tr>
			</table>

			<section id="constraints-value-type">
				<h3>Value Type Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they define restrictions
					on the type of the nodes.
				</p>
				<p class="issue" data-number="141" title="How to represent mixed datatype-or-class ranges">
					It is an open issue how to best represent properties that may either take a literal or a non-literal.
				</p>
				<section id="ClassConstraintComponent">
					<h4>sh:class</h4>
					<p>
						The property <code>sh:class</code> can be used to verify that each <span class="term">value node</span> is a <a>SHACL instance</a> of a given type.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:class</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is either a <a>literal</a>, or a non-literal that is not a <a>SHACL instance</a> of the given <a>class</a> in the <a>data graph</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* $class } .
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:knows ;
		sh:class ex:Person ;
	] .</pre>

					<pre class="example-data">
ex:Alice a ex:Person .
ex:Bob ex:knows ex:Alice .
<span class="focus-node-error">ex:Carol</span> ex:knows ex:Bob .</pre>
				</section>

				<section id="ClassInConstraintComponent">
					<h4>sh:classIn</h4>
					<p>
						The property <code>sh:classIn</code> can be used to verify that each <a>value node</a> is a <a>SHACL instance</a> of a type from a given list.
						The values of <code>sh:classIn</code> must be lists of resources.
						<code>sh:classIn</code> is a generalization of <code>sh:class</code> allowing users to state that the values must have at least one out of several types.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassInConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:classIn</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>List of types of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							that is a literal, and for each <a>value node</a> that is not a <a>SHACL instance</a> of one of the given <a>classes</a> in the <a>data graph</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
			GRAPH $shapesGraph {
				$classIn (rdf:rest*)/rdf:first ?class .
			}
			FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* ?class }
		}
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassInExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:affiliatedWith ;
		sh:classIn ( ex:University ex:Organisation ) ;
	] .</pre>

					<pre class="example-data">
ex:MIT a ex:University .
ex:W3c a ex:Organisation .

ex:Bob ex:affiliatedWith ex:MIT .
ex:Alice ex:affiliatedWith ex:W3c .
<span class="focus-node-error">ex:Carol</span> ex:affiliatedWith ex:ABC .</pre>
				</section>

				<section id="DatatypeConstraintComponent">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all <a>value nodes</a>.
						The values of <code>sh:datatype</code> must be resources representing datatypes, such as <code>xsd:string</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Datatype of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							that is not a <a>literal</a>, or is a <a>literal</a> with a mismatching datatype.
							A <a>literal</a> matches a datatype if the <a>literal</a>'s datatype has the same <a>IRI</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isLiteral(?value) || datatype(?value) != $datatype) .
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatype property constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:age ;
		sh:datatype xsd:integer ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:age "23"^^xsd:integer .
<span class="focus-node-error">ex:Bob</span> ex:age "twenty two" .</pre>
				</section>

				<section id="DatatypeInConstraintComponent">
					<h4>sh:datatypeIn</h4>
					<p>
						The property <code>sh:datatypeIn</code> can be used to restrict the datatype of all <a>value nodes</a>.
						The values of <code>sh:datatypeIn</code> must be lists of resources representing datatypes, such as <code>xsd:string</code>.
						<code>sh:datatypeIn</code> is a generalization of <code>sh:datatype</code> allowing users to state that the values must have one out of several datatypes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeInConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>Allowed datatypes of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							that is not a <a>literal</a>, or is a <a>literal</a> with a mismatching datatype.
							A <a>literal</a> matches if the <a>literal</a>'s datatype is member of the provided datatypes list.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$datatypeIn (rdf:rest*)/rdf:first ?datatype .
			}
			BIND (datatype(?value) AS ?valueDatatype) .
			FILTER (?valueDatatype = $datatype) .
		})
	}
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatypeIn property constraint">
ex:DatatypeInExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice, ex:Ted ;
	sh:property [
		sh:predicate ex:name ;
		sh:datatypeIn ( xsd:string rdf:langString ) ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:name "Bob"@en .
ex:Alice ex:name "Alice" .
<span class="focus-node-error">ex:Ted</span> ex:name 23 .</pre>
				</section>
				<section id="NodeKindConstraintComponent">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> is used to restrict the RDF node kind of each <a>value node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NodeKindConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, literal or combinations of these) of all value nodes</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be <a>SHACL instances</a> of the class <code>sh:NodeKind</code>.
						The SHACL system vocabulary defines that <code>sh:NodeKind</code> has exactly six instances:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> as well as the
						following values that represent combinations of the former three, i.e. either-or:
						<code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							that does not match the given node kind.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		FILTER ((isIRI(?value) &amp;&amp; $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
				(isLiteral(?value) &amp;&amp; $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
				(isBlank(?value)   &amp;&amp; $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice ;
	sh:property [
		sh:predicate ex:knows ;
		sh:nodeKind ex:IRI ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:knows ex:Alice .
<span class="focus-node-error">ex:Alice</span> ex:knows "Bob" .</pre>
				</section>
			</section>

			<section id="constraints-count">
				<h3>Cardinality Constraint Components</h3>
				<p>
					The <a>constraint components</a> in this section can be applied to either a <a>property constraint</a> or an <a>inverse property constraint</a>,
					to represent restrictions on the number of <a>values</a> that the <a>focus node</a> may have for these properties.
				</p>
				<section id="MinCountConstraintComponent">
					<h4>sh:minCount</h4>
					<p>
						The property <code>sh:minCount</code> restricts the number of <a>value nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinCountConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality. If the value is 0 then this constraint is always satisfied and so may be omitted.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of
							<a>value nodes</a> is less than the value of <code>sh:minCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &lt; $minCount)
}</pre>
					</div>
					<pre class="example-shapes">
ex:MinCountExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:name ;
		sh:minCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:name "Alice" .
<span class="focus-node-error">ex:Bob</span> ex:givenName "Bob"@en .</pre>
				</section>

				<section id="MaxCountConstraintComponent">
					<h4>sh:maxCount</h4>
					<p>
						The property <code>sh:maxCount</code> restricts the number of <a>value nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxCountConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality. If this parameter is omitted then there is no limit on the number of triples.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of
							<a>value nodes</a> is greater than the value of <code>sh:maxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &gt; $maxCount))
}</pre>
					</div>
					<pre class="example-shapes">
ex:MaxCountExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob ;
	sh:property [
		sh:predicate ex:birthDate ;
		sh:maxCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:birthDate "May 5th 1990" .</pre>
				</section>
			</section>

			<section id="constraints-range">
				<h3>Value Range Constraint Components</h3>
				<p>
					The following constraint components represent range restrictions on nodes that are comparable
					via operators such as <code>&lt;</code> and <code>&gt;</code>.
				</p>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of <a>value nodes</a>.
						The supported datatypes of these nodes are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<p>
						<span class="component-class">Constraint Components:</span> <code>sh:MinExclusiveConstraintComponent</code>, <code>sh:MinInclusiveConstraintComponent</code>, <code>sh:MaxExclusiveConstraintComponent</code>, <code>sh:MaxInclusiveConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="MinExclusiveConstraintComponent">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="MinInclusiveConstraintComponent">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="MaxExclusiveConstraintComponent">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="MaxInclusiveConstraintComponent">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							that does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <span class="term">validation result</span> must also be produced if the node cannot be compared to the specified range.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the validation engine will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p>
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&gt;</code> operator and the <code>$minExclusive</code> variable.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	BIND (?value &gt; $minExclusive AS ?result) .
	FILTER (!?result || !bound(?result)) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice, ex:Ted ;
	sh:property [
		sh:predicate ex:age ;
		sh:minInclusive 0 ;
		sh:maxInclusive 150 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:age 23 .
<span class="focus-node-error">ex:Alice</span> ex:age 220 .
<span class="focus-node-error">ex:Ted</span> ex:age "twenty one" .</pre>
				</section>
			</section>

			<section id="constraints-string">
				<h3>String-based Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they are representing
					restrictions on the string representation of certain nodes.
				</p>
				<section id="MinLengthConstraintComponent">
					<h4>sh:minLength</h4>
					<p>
						The property <code>sh:minLength</code> restricts the string length of <a>value nodes</a>.
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinLengthConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. If the value is 0 then there is no restriction on the string length but this constraint is still violated if the node is a blank node.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is less than the specified minimum length, or if the node is a <a>blank node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &lt; $minLength) .
}</pre>
					</div>
				</section>

				<section id="MaxLengthConstraintComponent">
					<h4>sh:maxLength</h4>
					<p>
						The property <code>sh:maxLength</code> restrict the string length of <a>value nodes</a>
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxLengthConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. If this constraint is omitted then there is no restriction on the string length and no requirement that the node is a literal or IRI.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is greater than the specified maximum length, or if the node is a <a>blank node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &gt; $maxLength) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:password "123456789" .
<span class="focus-node-error">ex:Alice</span> ex:password "1234567890ABC" .</pre>
				</section>

				<section id="PatternConstraintComponent">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all <a>value nodes</a> match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:PatternConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all value nodes must match</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td><code>xsd:string</code> (optional)</td>
							<td>An optional string of flags, interpreted as in <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL 1.1 REGEX</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a> that is a <a>blank node</a> or
							where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							If <code>sh:flags</code> is present then this must be interpreted according to the SPARQL REGEX function.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || IF(bound($flags), !regex(str(?value), $pattern, $flags), !regex(str(?value), $pattern))) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:bCode ;
		sh:pattern "^B" ;    # starts with 'B'
		sh:flags "i" ;       # Ignore case
	] .</pre>
					<pre class="example-data">
ex:Bob ex:bCode "b101" .
ex:Alice ex:bCode "B102" .
<span class="focus-node-error">ex:Carol</span> ex:bCode "C103" .</pre>
				</section>

				<section id="StemConstraintComponent">
					<h4>sh:stem</h4>
					<p>
						The property <code>sh:stem</code> validates whether all <a>value nodes</a> are IRIs and the IRI starts with a given string value.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:StemConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:stem</code></td>
							<td><code>xsd:string</code></td>
							<td>String value that an IRI must start with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a>
							that is not an <a>IRI</a> or the <a href="https://www.w3.org/TR/sparql11-query/#func-str">string representation</a> of the <a>IRI</a> does not <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#func-strstarts">start with</a> the given string.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isIRI(?value) || !STRSTARTS(str(?value), $stem) ) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:StemExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:w3cHomepage ;
		sh:stem "https://www.w3.org/People/" ;
	] .</pre>
					<pre class="example-data">
ex:Alice ex:w3cHomepage &lt;https://www.w3.org/People/Alice&gt; .
<span class="focus-node-error">ex:Bob</span> ex:w3cHomepage &lt;https://example.com/People/Bob&gt; .
<span class="focus-node-error">ex:Carol</span> ex:w3cHomepage "https://www.w3.org/People/Carol" .</pre>
				</section>

				<section id="UniqueLangConstraintComponent">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of <a>value nodes</a> may use the same language tag.
						The values of <code>sh:uniqueLang</code> must be <code>xsd:boolean</code>s.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:UniqueLangConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td><code>xsd:boolean</code></td>
							<td><code>true</code> to activate this constraint</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:uniqueLang</code> is set to <code>true</code> then a <span class="term">validation result</span> must be produced for each non-empty language tag that is
							used by at least two <a>value nodes</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ($this AS ?subject) $predicate ?lang
WHERE {
	{
		FILTER ($uniqueLang) .
	}
	$this $predicate ?value .
	BIND (lang(?value) AS ?lang) .
	FILTER (bound(?lang) &amp;&amp; ?lang != "") .
	FILTER EXISTS {
		$this $predicate ?otherValue .
		FILTER (?otherValue != ?value &amp;&amp; ?lang = lang(?otherValue)) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:UniqueLangExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:label ;
		sh:uniqueLang true ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:label "Alice" ;
	ex:label "Alice"@en ;
	ex:label "Alice"@fr .

<span class="focus-node-error">ex:Bob</span>
	ex:label "Bob"@en ;
	ex:label "Bobby"@en .</pre>
				</section>
			</section>

			<section id="constraints-property-pairs">
				<h3>Property Pair Constraint Components</h3>
				<p>
					The constraint components in this section restrict the sets of values represented by
					the <code>sh:predicate</code> used in the property constraint, and another property
					that is specified as the value of the respective parameter such as <code>sh:equals</code>.
				</p>

				<section id="EqualsConstraintComponent">
					<h3>sh:equals</h3>
					<p>
						<code>sh:equals</code> constrains a pair of properties so that the sets of values of both properties at a given focus node must be equal.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:EqualsConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:equals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Property to compare with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced
							for each <a>value</a> of <code>sh:predicate</code> that does not exist as <a>value</a> of <code>sh:equals</code> and
							for each <a>value</a> of <code>sh:equals</code> that does not exist as <a>value</a> of <code>sh:predicate</code>
							at the given <a>focus node</a>.
							The produced <span class="term">validation result</span> must have the corresponding values of the existing triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	{
		$this $predicate ?object .
		FILTER NOT EXISTS {
			$this $equals ?object .
		}
	}
	UNION
	{
		$this $equals ?object .
		FILTER NOT EXISTS {
			$this $predicate ?object .
		}
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to verify
						that certain nodes must have the same set of values for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:EqualExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:equals ex:givenName ;
	] .</pre>
					<pre class="example-data">
ex:Bob
	ex:firstName "Bob" ;
	ex:givenName "Bob" .</pre>
				</section>

				<section id="DisjointConstraintComponent">
					<h3>sh:disjoint</h3>
					<p>
						<code>sh:disjoint</code> constrains a pair of properties so that the sets of <a>values</a> of both properties at a given <a>focus node</a> must not share any nodes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DisjointConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:disjoint</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value</a> of <code>sh:predicate</code>
							that also exists as <a>value</a> of <code>sh:disjoint</code> at the given <a>focus node</a>.
							The produced <span class="term">validation result</span> must have the <a>focus node</a> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the <a>value</a> as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $disjoint ?object .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:disjoint</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example-shapes">
ex:DisjointExampleShape
	a sh:Shape ;
	sh:scopeNode ex:USA, ex:Germany ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:disjoint ex:altLabel ;
	] .</pre>
					<pre class="example-data">
ex:USA
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

<span class="focus-node-error">ex:Germany</span>
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>

				<section id="LessThanConstraintComponent">
					<h3>sh:lessThan</h3>
					<p>
						<code>sh:lessThan</code> constrains a pair of properties so that the <a>values</a> of the first property must be smaller than the <a>values</a> of the second property at a given <a>focus node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of <a>values</a> of <code>sh:predicate</code>
							and <code>sh:lessThan</code> at the given <a>focus node</a>, where
							the first <a>value</a> is not less than the second <a>value</a>, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two <a>values</a> cannot be compared.
							The produced <span class="term">validation result</span> must have the <a>focus node</a> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the <a>value</a> of the property specified by <code>sh:predicate</code> as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThan ?object2 .
	FILTER (!(?object &lt; ?object2)) .
}</pre>
					</div>
					<p class="todo">TODO: Decide what should happen if values are not comparable, i.e. &lt; fails, similar to minExclusive etc.</p>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to verify
						that all values of <code>ex:startDate</code> must be "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example-shapes">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:startDate ;
		sh:lessThan ex:endDate ;
	] .</pre>
				</section>

				<section id="LessThanOrEqualsConstraintComponent">
					<h3>sh:lessThanOrEquals</h3>
					<p>
						<code>sh:lessThanOrEquals</code> constrains a pair of properties so that the <a>values</a> of the first property must be smaller than or equal to the <a>values</a> of the second property at a given <a>focus node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanOrEqualsConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of <a>values</a> of <code>sh:predicate</code>
							and <code>sh:lessThanOrEquals</code> at the given <a>focus node</a>, where
							the first <a>value</a> is not less than or equal to the second value, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two <a>values</a> cannot be compared.
							The produced <span class="term">validation result</span> must have the <a>focus node</a> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the <a>value</a> of the property specified by <code>sh:predicate</code> as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThanOrEquals ?object2 .
	FILTER (!(?object &lt;= ?object2)) .
}</pre>
					</div>
				</section>
			</section>

			<section id="constraints-logical">
				<h3>Logical Constraint Components</h3>
				<p>
					The constraint components in this section implement the common logical operators <span class="term">and</span>,
					<span class="term">or</span> and <span class="term">not</span>.
				</p>
				<p class="issue" data-number="135" title="Should sh:and/sh:or/sh:not support constraints too">
					There is a proposal to generalize the following components to also allow their values to be constraints, not just shapes.
				</p>
				<section id="NotConstraintComponent">
					<h3>sh:not</h3>
					<p>
						SHACL supports a high-level negation constraint that can be used to verify that a <a>value node</a> does not have a given <a>shape</a>.
						This is comparable to a logical "not" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NotConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:not</code></td>
							<td><code>sh:Shape</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a> that produces no validation results with severity <code>sh:Violation</code> for the shape given via <code>sh:not</code>.
							A <a>failure</a> must be reported if the validation of the shape produces a <a>failure</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for node constraints)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $not, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example-shapes">
ex:NotExampleShape
	a sh:Shape ;
	sh:scopeNode ex:InvalidInstance1 ;
	sh:constraint [
		sh:not [
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:minCount 1 ;
			] ;
		]
	] .</pre>
					<pre class="example-data">
<span class="focus-node-error">ex:InvalidInstance1</span> ex:property "Some value" .</pre>
				</section>

				<section id="AndConstraintComponent">
					<h3>sh:and</h3>
					<p>
						SHACL supports a high-level syntax for conjunctive constraints that can be used to test whether a <a>value node</a> has all out of several shapes.
						This is comparable to a logical "and" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:AndConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:and</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the <a>shapes</a> in the <code>sh:and</code> list produces a <a>validation result</a> with severity <code>sh:Violation</code> for at least one shape.
							A <a>failure</a> must be produced if the validation of one of the shapes produces a <a>failure</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for node constraints)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$and rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(!?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:and</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that further constrains the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes.
					</p>
					<pre class="example-shapes">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:scopeNode ex:ValidInstance, ex:InvalidInstance ;
	sh:constraint [
		sh:and (
			ex:SuperShape
			[
				a sh:Shape ;
				sh:property [
					sh:predicate ex:property ;
					sh:maxCount 1 ;
				]
			]
		)
	] .</pre>

<pre class="example-data">
ex:ValidInstance
	ex:property "One" .

# Invalid: more than one property
<span class="focus-node-error">ex:InvalidInstance</span>
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>

				<section id="OrConstraintComponent">
					<h3>sh:or</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether a <a>value node</a> has at least one out of several shapes.
						This is comparable to a logical "or" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:OrConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:or</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the <a>shapes</a> in the <code>sh:or</code> list produces no <a>validation results</a> with severity <code>sh:Violation</code> for at least one shape.
							A <a>failure</a> must be produced if the <a>validation</a> of one of the shapes produces a <a>failure</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for node constraints)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$or rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count = 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:or</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:firstName</code>
						or at least one value of <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Bob ;
	sh:constraint [
		sh:or (
			[
				sh:property [
					sh:predicate ex:firstName ;
					sh:minCount 1 ;
				]
			]
			[
				sh:property [
					sh:predicate ex:givenName ;
					sh:minCount 1 ;
				]
			]
		)
	] .</pre>
					<pre class="example-data">
ex:Bob ex:firstName "Robert" .</pre>
				</section>
			</section>

			<section id="constraints-shape">
				<h3>Shape-based Constraint Components</h3>
				<p>
					The constraint components in this section can be used to represent complex restrictions
					based on applying shape definitions on the property values.
				</p>

				<section id="ShapeConstraintComponent">
					<h4>sh:shape</h4>
					<p>
						The property <code>sh:shape</code> can be used verify that all <a>value nodes</a> must have a given shape.
						The value type of <code>sh:shape</code> is <code>sh:Shape</code>, but the <code>rdf:type</code> triple of those shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ShapeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:shape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all value nodes</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							where validating the value node against the shape specified by <code>sh:shape</code>
							produces any validation results with severity <code>sh:Violation</code>.
							A <a>failure</a> must be produced if the validation of any <a>value node</a> has produced a <a>failure</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object ?failure
WHERE {
	$this $predicate ?object .
	BIND (sh:hasShape(?object, $shape, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<p>
						A shape may refer to itself directly or indirectly via <code>sh:shape</code>, <code>sh:filterShape</code>, etc.
						Such a shape is said to be <em>recursive</em>.
						The meaning of non-recursive shapes is always well-founded.
						In contrast, the meaning of a recursive shape may not be well-founded.
						The handling of recursive shapes in SHACL is left to implementations.
						Some implementations MAY reject shapes graphs containing recursive shape definitions.
						Some implementations MAY report a <a>failure</a> if a recursion has been detected at validation time.
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> will validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example-shapes">
ex:ShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:shape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .</pre>

					<pre class="example-data">
ex:ShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>

				<section id="QualifiedValueShapeConstraintComponent">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<div class="issue" data-number="92" title="Relationship of QCRs with Partitions">
						Feature at risk:
						There is an ongoing proposal (see sh:partition) that strongly overlaps with the QCRs proposed here.
						The WG may decide to support only one of these options, but not both.
					</div>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number of <a>value nodes</a> must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						The <code>rdf:type</code> of the value shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:QualifiedValueShapeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape. If this constraint is omitted then there is no minimum number of values required.</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape. If this constraint is omitted then there is no maximum number of values required.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body">
							Let <code>C</code> be the number of <a>value nodes</a> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no <a>validation results</a> with severity <code>sh:Violation</code>.
							A <a>failure</a> must be produced if the validation of any of the value nodes produces a <a>failure</a>.
							A <span class="term">validation result</span> must be produced if <code>C</code>
							is less than the specified <code>sh:qualifiedMinCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMinCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &lt; $qualifiedMinCount) .
}</pre>
					</div>
					<p>
						Note that in the SPARQL query above, we assume that the <code>SUM</code> operation fails
						if one of the values of <code>?s</code> is not a number.
						This mechanism is used by the error handling, which sets <code>?s</code> to the string <code>'error'</code>
						whenever one of the individual <code>sh:hasShape</code> calls fails.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body">
							Let <code>C</code> be the number of <a>value nodes</a> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no <a>validation results</a> with severity <code>sh:Violation</code>.
							A <a>failure</a> must be produced if the validation of any of the <a>value nodes</a> produces a <a>failure</a>.
							A <span class="term">validation result</span> must be produced if <code>C</code>
							is greater than the specified <code>sh:qualifiedMaxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMaxCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; $qualifiedMaxCount) .
}</pre>
					</div>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example-shapes">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:scopeNode ex:QualifiedValueShapeExampleValidResource ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>

				<section id="PartitionConstraintComponent">
					<h4>sh:partition</h4>
					<p>
						In some cases a given property may be multi-valued and it may be required that the set of values
						be partitioned into two or more subsets, each of which satisfies certain constraints.
					</p>
					<p>
						For example, suppose that in the Library of Congress BIBFRAME (<code>bf:</code>) Cultural Heritage vocabulary each person (<code>bf:Person</code>) must be identified by
						(<code>bf:identifiedBy</code>) exactly one identifier from <code>id.loc.gov</code> and may have another identifier
						from <code>viaf.org</code>. No other identifiers are allowed. Thus the set of all identifiers is partitioned into
						two subsets, the first of which contains exactly one member and the second of which contains zero or one members.
						The following example shows a snippet of some valid BIBFRAME data.
					</p>
					<pre class="example-data" title="Valid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> .</pre>
					<p>
						The following example shows a snippet of some invalid BIBFRAME data.
					</p>
					<pre class="example-data" title="Invalid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> ;
	bf:identifiedBy "this is a mistake" . # should be an error</pre>
					<p>
						Qualified cardinality constraints provide a basis for expressing this type of partitioning requirement, but using them imposes a burden on the shapes author. In the BIBFRAME example the author would need to express the requirement that the set of all identifiers that are from neither <code>id.loc.gov</code> nor <code>viaf.org</code> is empty, i.e. it has a maximum cardinality of 0. Clearly, as more subsets of values are involved, the burden on the author increases.
						The <code>sh:partition</code> constraint makes it easier to express this type of requirement than it would be to use
						multiple qualified cardinality constraints.
						In effect, <code>sh:partition</code> chains together a sequence of qualified cardinality constraints and removes the set of context nodes matched by each from further consideration. If every context node gets matched in this process, then
						the <code>sh:partition</code> constraint reports no violations. Otherwise, any context nodes remaining are reported as
						violations of the constraint.
						The BIBFRAME example constraint is expressed as follows.
					</p>
					<pre class="example-shapes" title="BIBFRAME constraint expressed using sh:partition">
ex:BibframeShape a sh:Shape ;
	sh:property [
		sh:predicate bf:identifiedBy ;
		sh:partition (
			[sh:minCount 1; sh:maxCount 1; sh:pattern "^http://id.loc.gov/"]
			[sh:maxCount 1; sh:pattern "^https://viaf.org/"]
		)
] .</pre>
					<p>
						The value of the <code>sh:partition</code> constraint parameter MUST be an <code>rdf:List</code> that contains zero or more resources.
						Each resource in the list defines conditions on a subset of the context nodes and MAY contain the following parameters:
					</p>
					<ul>
						<li>zero or one <code>sh:minCount</code>. This defines the minimum cardinality of the corresponding subset.</li>
						<li>zero or one <code>sh:maxCount</code>. This defines the maximum cardinality of the corresponding subset.</li>
						<li>any combination of parameters associated with node validation constraints. A node validation constraint
							is any constraint defined by a boolean function on nodes.
							These include the built-in constraints defined by <code>sh:nodeKind</code>, <code>sh:partition</code>,
							<code>sh:minExclusive</code>, etc.
							The corresponding subset consists of those remaining nodes for which the boolean function is <code>true</code>.</li>
					</ul>
					<p>
						Note that a resource that contains no parameters matches all nodes. Such a resource is useful as the last member of the list where it acts as a default matching rule in the case where nodes that do not match any of the preceeding constraints are allowed.
						Note also that a qualified cardinality constraint defined using <code>sh:qualifiedValueShape</code>,
						<code>sh:qualifiedMinCount</code>, and <code>sh:qualifiedMaxCount</code> is equivalent to a <code>sh:partition</code> constraint that contains two resources with the first one containing the corresponding parameters and the last one being the default matching rule that matches any set of nodes.
					</p>
					<p>
						Each member of the list is used by the SHACL processor to match a subset of the context nodes.
						The SHACL processor matches as many nodes as possible and then compares the result with the specified
						minimum and maximum cardinalities if specified. This is referred to as a <em>greedy</em> matching algorithm.
						Greedy pattern matching is commonly used with textual regular expressions.
						Nodes that match are removed from further matching. Thus the set of all context nodes becomes partitioned by
						the matching algorithm. The following paragraphs define this algorithm more precisely.
					</p>
					<p>
						Let D be a data graph and let F be a focus node in D. Let S be a shapes graph, let T be a shape in S,
						and let C be a <code>sh:partition</code> constraint in T.
						Let N be the set of context nodes for C in D at F. Recall that N depends on how C is related to T.
					</p>
					<ul>
						<li>If (T, <code>sh:constraint</code>, C) is in S then N consists of just the node F.</li>
						<li>If (T, <code>sh:property</code>, C) and (C, <code>sh:predicate</code>, P) are in S
							then N consists of all the nodes X such that (F, P, X) is in D.</li>
						<li>If (T, <code>sh:inverseProperty</code>, C) and (C, <code>sh:predicate</code>, P) are in S
							then N consists of all the nodes X such that (X, P, F) is in D.</li>
					</ul>
					<p>
						Let the value of the <code>sh:partition</code> parameter be the list (Q<sub>1</sub>, ..., Q<sub>n</sub>) of resources.
						The SHACL validator MUST perform the following steps to validate the constraint C at F.
					</p>
					<ol>
						<li>Let R denote the set of remaining context nodes. Initialize R to N.</li>
						<li>Repeat the following for Q = Q<sub>1</sub>, ..., Q<sub>n</sub>
						<ol>
							<li>Let P be the conjunction of all the node validation constraints in Q.</li>
							<li>Compute R' to be the set of all nodes in R that satisfy P, i.e. R' = {X in R | P(X) = true}</li>
							<li>If Q contains a minimum cardinality m<sub>min</sub> and the number of nodes in R' is less than m<sub>min</sub>,
							i.e. m<sub>min</sub> > #R', then report a constraint violation and exit the loop.</li>
							<li>If Q contains a maximum cardinality m<sub>max</sub> and the number of nodes in R' is greater then m<sub>max</sub>,
							i.e. m<sub>max</sub> &lt; #R', then report a constraint violation and exit the loop.</li>
							<li>Remove R' from R, i.e. set R = R \ R'.</li>
						</ol>
						</li>
						<li>If R is non-empty and no violations have been reported yet then report a violation.</li>
					</ol>
					<p>
						Note that the order of resources within the list is significant.
						In general, if the members of the list are reordered then different context node sets will be matched
						and different violation results will be reported.
					</p>
				</section>
			</section>

			<section id="constraints-others">
				<h3>Other Constraint Components</h3>
				<p>
					This section enumerates core constraint components that did not fit into the other categories.
				</p>

				<section id="ClosedConstraintComponent">
					<h3>sh:closed, sh:ignoredProperties</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any resource can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to resources.
						The SHACL core language includes a property called <code>sh:closed</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClosedConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:closed</code></td>
							<td><code>xsd:boolean</code></td>
							<td>Set to <code>true</code> to close the shape</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
							<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:closed</code> is <code>true</code> then
							a <span class="term">validation result</span> must be produced for each <a>triple</a> that has the <a>focus node</a> as its
							<a>subject</a> and a <a>predicate</a> that is not explicitly enumerated as a <code>sh:predicate</code>
							in any of the <code>sh:property</code> constraints at the surrounding shape.
							If the parameter <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
							The produced <span class="term">validation result</span> must have the corresponding values of the triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<p>
						The core vocabulary includes an instance of <code>sh:NodeConstraint</code> called <code>sh:Closed</code>
						that can be used in places where no other parameters such as <code>sh:ignoredProperties</code> are needed.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ?predicate ?object
WHERE {
	{
		FILTER $closed .
	}
	$this ?predicate ?object .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:scopeNode ex:Alice, ex:Bob ;
	sh:constraint [
		sh:closed true ;
		sh:ignoredProperties (rdf:type) ;
	] ;
	sh:property [
		sh:predicate ex:firstName ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:firstName "Alice" .

<span class="focus-node-error">ex:Bob</span>
	ex:firstName "Bob" ;
	ex:middleInitial "J" .</pre>
					<p>
						The next example illustrates a more compact syntax using the built-in instance <code>sh:Closed</code>.
						In this form, no ignored properties can be specified.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint sh:Closed ;
	sh:property [
		sh:predicate ex:firstName ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
	] .</pre>
				</section>

				<section id="HasValueConstraintComponent">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify that one of the <a>value nodes</a> is a given RDF node.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:HasValueConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the node specified by <code>sh:hasValue</code> is not among the <a>value nodes</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	FILTER NOT EXISTS {
		$this $predicate $hasValue .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:StanfordGraduate
	a sh:Shape ;
	sh:scopeNode ex:Alice ;
	sh:property [
		sh:predicate ex:alumniOf ;
		sh:hasValue ex:Stanford ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:alumniOf ex:Harvard ;
	ex:alumniOf ex:Stanford .</pre>
				</section>

				<section id="InConstraintComponent">
					<h4>sh:in</h4>
					<p>
						The property <code>sh:in</code> exclusively enumerates the permitted <a>value nodes</a>.
						For example when specified as part of a <a>property constraint</a>, then each <a>value</a> of the given property must be a member of the specified list.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:InConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:in</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:in</code> must be well-formed <code>rdf:List</code>s.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <span class="term">validation result</span> must be produced for every <a>value node</a>
							that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		GRAPH $shapesGraph {
			$in (rdf:rest*)/rdf:first ?value .
		}
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:InExampleShape
	a sh:Shape ;
	sh:scopeNode ex:RainbowPony ;
	sh:property [
		sh:predicate ex:color ;
		sh:in ( ex:Pink ex:Purple ) ;
	] .</pre>

					<pre class="example-data">
ex:RainbowPony ex:color ex:Pink .</pre>
				</section>
			</section>

			<section id="nonValidation">
				<h4>Non-Validating Constraint Characteristics</h4>
				<p>
					While the previous sections introduced properties that represent validation conditions,
					this section covers properties that are ignored by SHACL validation engines.
					The use of these properties is entirely optional and not subject to formal interpretation contracts.
					They may be used for purposes such as form building or predictable printing of RDF files.
				</p>
				<p id="name">
					Property constraints may have one or more <a>values</a> for <code>sh:name</code> to provide human-readable labels for the property in the scope where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a resource that is in the scope of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>sh:name</code>, then the tool SHOULD use the provided name.
					Similarly, property constraints may have an <code id="description">sh:description</code> to provide a description of the property in the given context.
					Both <code>sh:name</code> and <code>sh:description</code> may have multiple <a>values</a>, but SHOULD only have one <a>value</a> per language tag.
				</p>
				<p id="order">
					Property constraints may have one <a>value</a> for the property <code>sh:order</code> to indicate the relative order of the property constraint for purposes such as form building.
					The values of <code>sh:order</code> must be decimals.
					<code>sh:order</code> is not used for validation purposes.
					If present, the recommended use of <code>sh:order</code> is to sort the property constraints in an ascending order, for example so that
					properties with smaller order are placed above (or to the left) of properties with larger order.
				</p>
				<p id="group">
					Property constraints may link to an <a>SHACL instance</a> of the class <code>sh:PropertyGroup</code> using the property <code>sh:group</code> to indicate that
					the constraint belongs to a group of related property constraints.
					Each group may have additional triples that serve application purposes, such as an <code>rdfs:label</code> for form building.
					Groups may also have an <code>sh:order</code> property to indicate the relative ordering of groups within the same form.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code> or <code>sh:class</code> of the same constraint.
				</p>
				<p>
					The following example illustrates the use of these various features together.
				</p>
				<pre class="example-shapes">
ex:PersonFormShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:locality ;
		sh:name "locality" ;
		sh:description "The suburb, city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-US ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .</pre>
				<p>
					A form building application may use the information above to display information as follows:
				</p>
				<div style="background: #f3f3f3; padding: 8px">
					<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>first name:</b></td>
							<td>John</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>last name:</b></td>
							<td>Doe</td>
						</tr>
					</table>
					<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>street address:</b></td>
							<td>123 Silverado Ave</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>locality:</b></td>
							<td>Cupertino</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>zip code:</b></td>
							<td>54321</td>
						</tr>
					</table>
				</div>
			</section>
		</section>

		<div style="padding-top: 30px">
			<h1 id="part2" style="font-size: 160%; font-weight: bold">Part 2: Advanced Features</h1>
			<p>
				Part 1 of this specification introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and scopes with greater flexibility.
				These mechanisms are described in the following sections.
			</p>
		</div>

		<section id="sparql-constraints">
			<h2>SPARQL-based Constraints</h2>
			<p>
				SHACL supports two mechanisms to define constraints using SPARQL:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#constraint-components">constraint components</a>), relying on a reusable SPARQL query in the background</li>
				<li>Constraints directly based on a SPARQL query</li>
			</ul>
			<p>
				The following sub-sections are about the latter.
			</p>
			<section id="sparql-constraints-syntax">
				<h3>Syntax of SPARQL-based Constraints</h3>
				<p>
					<code>sh:SPARQLConstraint</code> is a <a>SHACL subclass</a> of <code>sh:Constraint</code> and is the class of all SPARQL-based constraints.
					SPARQL-based constraints must have exactly one value for the property <code>sh:select</code>.
					The SPARQL queries linked to a <span class="term">constraint</span> via <code>sh:select</code> must be string literals that can be parsed into legal SPARQL 1.1 queries	of the query form <code>SELECT</code>.
				</p>
				<p class="issue" data-number="105" title="Defined prefixes">
					There is an ongoing discussion about whether and how to inject prefixes into SPARQL queries,
					so the following paragraph may change.
				</p>
				<p id="sparql-prefixes">
					Before parsing the values of <code>sh:select</code>, a SHACL processor must prepend <a href="https://www.w3.org/TR/sparql11-query/#rPrefixDecl"><code>PREFIX</code></a> declarations
					for all namespace prefixes declared via the property <code>sh:prefix</code> in the current <span class="term">shapes graph</span>.
					The subjects of <code>sh:prefix</code> triples must be IRIs, which become the <code>IRIREF</code> in the <code>PREFIX</code> declaration.
					The objects of <code>sh:prefix</code> triples must be string literals, which become the <code>PNAME_NS</code> in the <code>PREFIX</code> declaration.
					For the example shapes graph below, a SHACL processor would produce the line <code>PREFIX ex: &lt;http://example.com/ns#&gt;</code>.
					No such <code>PREFIX</code> must be generated if the SPARQL string already contains a <code>PREFIX</code> statement for the same <span class="term">prefix</span> at the top-level query
					(ignoring prefixes from nested SELECT queries).
					The SHACL processor must produce an <a>failure</a> if the <span class="term">shapes graph</span> contains multiple <code>sh:prefix</code> triples with the same object.
					Since the use of <code>sh:prefix</code> triples may lead to conflicts, it is recommended to only use them in closed and controlled environments or for well-established prefixes.
					In the rest of this document, the <code>sh:prefix</code> statements may have been omitted for brevity.
				</p>
				<p>
					The following example illustrates the definition of a <span class="term">SPARQL-based constraint</span>.
				</p>
				<pre class="example-data">
ex:ValidCountry a ex:Country ;
	ex:germanLabel "Spanien"@de .

<span class="focus-node-error">ex:InvalidCountry</span> a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<pre class="example-shapes" id="example-sparql-constraint">
&lt;http://example.com/ns#&gt; sh:prefix "ex" .

ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:sparql [
		a sh:SPARQLConstraint ;
		sh:message "Values must be literals with German language tag." ;
		sh:select """
			SELECT $this ($this AS ?subject) (ex:germanLabel AS ?predicate) (?value AS ?object)
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The scope of the shape above includes all <a>SHACL instances</a> of <code>ex:Country</code>.
					For those RDF nodes (represented by the variable <code>$this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The validation results for the aforementioned data graph is shown below:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:subject ex:InvalidCountry ;
	sh:predicate ex:germanLabel ;
	sh:object "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set rows for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each row in that result set, following the <a href="#sparql-constraints-variables">mapping rules</a> explained later:
					Each validation result will have <code>$this</code> as the <code>sh:focusNode</code> and <code>sh:subject</code>,
					<code>ex:germanLabel</code> as <code>sh:predicate</code> and the violating value as <code>sh:object</code>.
				</p>
				<!--p>
					In the example above, it is assumed that the existing SHACL validation engine is capable of evaluating constraints using SPARQL.
					Additional executable languages such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>,
					but that is outside of the scope of this specification.
				</p-->
			</section>
			<section id="sparql-constraints-prebound">
				<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
				<p>
					The following table enumerates variables that have special meaning in SPARQL constraints.
					When SPARQL constraints are executed, the validation engine should <a>pre-bind</a> values for these variables.
				</p>
				<table class="term-table">
					<tr>
						<th>Variable</th>
						<th>Interpretation</th>
					</tr>
					<tr>
						<td><code>$this</code></td>
						<td>
							The <span class="term">focus node</span>.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$shapesGraph</code></td>
						<td>
							Can be used to query the shapes graph as in <code>GRAPH $shapesGraph { ... }</code>.
							If the shapes graph is a named graph in the same dataset as the data graph then it is the IRI of the shapes graph in the dataset.
							Not all SHACL validation engines need to support this variable.
							Processors that do not support <code>$shapesGraph</code> MUST report an error if they encounter a query that references this variable.
							Use of <code>GRAPH $shapesGraph { ... }</code> should be handled with extreme caution.
							It may result in constraints that are not interoperable across different SHACL validation engines and that may not run on remote RDF datasets.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$currentShape</code></td>
						<td>
							The currently validated shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							The same support policies as for <code>$shapesGraph</code> apply for this variable.
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-variables">
				<h4>Mapping of Result Variables to Validation Results</h4>
				<p>
					If one of the rows of the result set produced by a SELECT query contains the binding <code>true</code>
					for the variable <code>?failure</code>, then the validation engine must signal an error.
				</p>
				<p>
					Otherwise, each row of the result set produced by a SELECT query must be converted into one validation result resource.
					The properties of those resources are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
					The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Production Rules</th>
					</tr>
					<tr>
						<td><code>sh:severity</code></td>
						<td>
							<ol>
								<li>The value of <code>sh:severity</code> of the constraint node</li>
								<li>For <span class="term">constraint components</span>, the value of <code>sh:severity</code> of the constraint component resource</li>
								<li><code>sh:Violation</code> as default</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:focusNode</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>$this</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:subject</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?subject</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:predicate</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?predicate</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:object</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?object</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:message</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?message</code></li>
								<li>
									The values of <code>sh:message</code> of the subject of the <code>sh:select</code> or <code>sh:ask</code> triple.
									These values may reference any variable from the SELECT result variables via <code>{?varName}</code>.
									If the constraint is based on a <a href="#constraint-components">constraint component</a>, then the component's parameter variables can also be used.
									The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
								</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceConstraint</code></td>
						<td>
							<ol>
								<li>The <span class="term">constraint</span> that was validated against</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceShape</code></td>
						<td>
							<ol>
								<li>The <span class="term">shape</span> that was validated against</li>
							</ol>
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-annotations">
				<h4>Injecting Annotation Properties into Validation Results</h4>
				<p>
					It is possible to inject additional <span class="term">annotation properties</span> into the validation result resources created for each row of the SELECT result sets.
					Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:select</code> or <code>sh:ask</code> triple.
					The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Value type</th>
						<th>Count</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:annotationProperty</code></td>
						<td><code>rdf:Property</code></td>
						<td><code>1&nbsp;(mandatory)</code></td>
						<td>The annotation property that shall be set</td>
					</tr>
					<tr>
						<td><code>sh:annotationVarName</code></td>
						<td><code>xsd:string</code></td>
						<td><code>0..1</code></td>
						<td>The name of the SPARQL variable to take the values from</td>
					</tr>
					<tr>
						<td><code>sh:annotationValue</code></td>
						<td></td>
						<td><code>0..unlimited</code></td>
						<td>Constant nodes that shall be used as default values</td>
					</tr>
				</table>
				<p>
					For each row of a SELECT result set, a SHACL processor must walk through the declared result annotations.
					The mapping from result annotations to SPARQL variables uses the following rules:
				</p>
				<ol>
					<li>If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the validation engine must look for the variable named after the <code>sh:annotationVarName</code></li>
					<li>Otherwise, the validation engine must derive a variable name from the value of <code>sh:annotationProperty</code> using the same <a>local name</a> mechanism as described earlier</li>
				</ol>
				<p>
					If a variable name could be determined, then the validation engine must copy the bindings for the given variable into the constructed validation results for the current row.
					If the variable has no binding in the result set row, then the value of <code>sh:annotationValue</code> must be used, if present.
				</p>
				<p>
					The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
				</p>
				<p>
					Here is a slightly complex example, illustrating the use of result annotations.
				</p>
				<pre class="example-shapes">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:scopeNode ex:ExampleRootResource ;
	sh:sparql [
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:select """
			SELECT $this ?subject (ex:property2 AS ?predicate) (?first AS ?object) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>

				<pre class="example-data">
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
				<p>
					Which produces the following validation result resource:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:subject ex:ExampleValueResource ;
	sh:predicate ex:property2 ;
	sh:object ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:constraint above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
			</section>
		</section>

		<section id="constraint-components">
			<h2>SPARQL-based Constraint Components</h2>
			<p>
				SPARQL-based constraints as introduced in the previous section provide a lot of flexibility.
				However, SPARQL-based constraints may be hard to understand for some people or lead to repetition.
				<span class="term">Constraint components</span> are a way to abstract the complexity of SPARQL and define high level reusable components similar to the <a href="#constraints">core constraint components</a>.
				The definition of such constraint components can be represented in the SHACL RDF vocabulary and thus shared and reused.
			</p>
			<p>
				<code>sh:ConstraintComponent</code> is the class of all constraint components.
				Each constraint component must define:
			</p>
			<ul>
				<li>one or more <a href="#constraint-components-parameters">parameters</a> (e.g. <code>sh:class</code>, <code>sh:stem</code>)</li>
				<li>one or more <a href="#constraint-components-context">contexts</a></li>
				<li>one <a href="#constraint-components-validators">validator</a> for each defined context</li>
			</ul>
			<section class="informative">
				<h3>An Example Constraint Component</h3>
				<p>
					The following example demonstrates how SPARQL-based constraint components can be applied to define core elements of the SHACL language itself.
					The example implements <a href="#PatternConstraintComponent"><code>sh:pattern</code> and <code>sh:flags</code></a> using a <a href="#SPARQLAskValidator">SPARQL ASK</a> query to validate that each <a>value node</a> matches a given regular expression.
					Note that this is only an example implementation and should not be considered normative.
				</p>
				<pre class="example-shapes" title="Constraint component based on SPARQL">
sh:PatternConstraintComponent
	a sh:ConstraintComponent ;
	sh:context sh:NodeConstraint, sh:PropertyConstraint, sh:InversePropertyConstraint ;
	sh:parameter [
		sh:predicate sh:pattern ;
		sh:order 0 ;
	] ;
	sh:parameter [
		sh:predicate sh:flags ;
		sh:optional true ;
		sh:order 1 ;
	] ;
	sh:nodeValidator shimpl:hasPattern ;
	sh:propertyValidator shimpl:hasPattern ;
	sh:inversePropertyValidator shimpl:hasPattern .

shimpl:hasPattern
	a sh:SPARQLAskValidator ;
	sh:message "Value does not match pattern {$pattern}" ;
	sh:ask "ASK { FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }" .</pre>
				<p>
					The following sections introduce the properties that constraint components may have.
					Some of these properties are independent of SPARQL-based execution and apply
					to constraint components based on other potential extension languages such as JavaScript too.
				</p>
			</section>
			<section id="constraint-components-parameters">
				<h3>Parameters Declaration (sh:parameter)</h3>
				<p>
					The parameters of a constraint component are declared via the property <code>sh:parameter</code>.
					Each parameter must be a <a>SHACL instance</a> of <code>sh:Parameter</code>, but the <code>rdf:type</code> triples can be omitted.
				</p>
				<p class="issue" data-number="107" title="Specifying SPARQL variable name">
					There is an open issue about the relationship between SPARQL variable name and sh:predicate.
					Possible revisions may require an additional property similar to sh:annotationVarName.
				</p>
				<p>
					Each <code>sh:Parameter</code> must have exactly one value <code>p</code> for the property <code>sh:predicate</code> and the value must be an IRI.
					The <dfn data-lt="local names">local name</dfn> of an <a>IRI</a> is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the <a>IRI</a>, not immediately preceded by the first colon in the <a>IRI</a>.
					The local names of the <a>values</a> of <code>sh:predicate</code> must fulfill the following conditions (to ensure that a correct mapping from parameters into SPARQL variables is possible):
				</p>
				<ul>
					<li>The <a>local name</a> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <a>parameter</a> for the same <a>constraint component</a> that has a <code>sh:predicate</code> with the same <a>local name</a></li>
					<li>The <a>local name</a> must not be <code>this</code>, <code>shapesGraph</code> or <code>currentShape</code>.</li>
					<li>The <a>local name</a> must not be <code>subject</code>, <code>predicate</code> or <code>object</code>.</li>
				</ul>
				<p>
					An <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
					Every <code>sh:ConstraintComponent</code> must have at least one non-optional parameter.
				</p>
				<p>
					The class <code>sh:Parameter</code> is defined as a <a>SHACL subclass</a> of <code>sh:PropertyConstraint</code>,
					and all properties that are applicable to property constraints may also be used for parameters.
					This includes descriptive properties such as <code>sh:name</code> and <code>sh:description</code>
					but also constraint parameters such as <code>sh:class</code>.
					Some implementations MAY use these constraint parameters to prevent the execution of constraint components with invalid parameter values.
				</p>
			</section>
			<section id="labelTemplate">
				<h3>Label Templates (sh:labelTemplate)</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used at any <span class="term">constraint component</span> to suggest how they could be rendered to humans.
					The values of <code>sh:labelTemplate</code> must be strings (possibly with language tag) that can reference the values of the declared parameters using the syntax <code>{?varName}</code> or <code>{$varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the parameter.
					At display time, these <code>{...}</code> blocks SHOULD be substituted with the actual parameter values.
					There may be multiple label templates for the same subject, assuming they do not have the same language tags.
				</p>
			</section>
			<section id="constraint-components-context">
				<h3>Constraint Component Context (sh:context)</h3>
				<p>
					Each <code>sh:ConstraintComponent</code> can define one or more contexts with the <code>sh:context</code> predicate.
					The values of <code>sh:Context</code> are restricted to:
				</p>
				<ul>
			    	<li><code>sh:PropertyConstraint</code>, to allow the constraint component parameters in <code>sh:property</code> definitions.</li>
					<li><code>sh:InversePropertyConstraint</code>, to allow the constraint component parameters in <code>sh:inverseProperty</code> definitions.</li>
					<li><code>sh:NodeConstraint</code>, to allow the constraint component parameters in <code>sh:constraint</code> definitions.</li>
				</ul>
			</section>
			<section id="constraint-components-validators">
				<h3>Validators</h3>
				<p>
					For every provided <span class="term">context</span> in the constraint component,
					a suitable <span class="term">validator</span> must be declared.
					Each context defines a dedicated property that links to a validator according to the following table.
				</p>
				<table class="term-table">
					<tr>
						<th>Context</th>
						<th>Validator Property</th>
					</tr>
					<tr>
						<td><code>sh:NodeConstraint</code></td>
						<td><code>sh:nodeValidator</code></td>
					</tr>
					<tr>
						<td><code>sh:PropertyConstraint</code></td>
						<td><code>sh:propertyValidator</code></td>
					</tr>
					<tr>
						<td><code>sh:InversePropertyConstraint</code></td>
						<td><code>sh:inversePropertyValidator</code></td>
					</tr>
				</table>
				<p>
					SHACL includes two types of validators, based on <a href="#SPARQLSelectValidator">SPARQL SELECT</a> or <a href="#SPARQLAskValidator">SPARQL ASK</a> queries.
					For each provided context, one <span class="term">validator</span> must be defined  in the shapes graph.

				</p>
				<section id="SPARQLSelectValidator">
					<h3>Validators based on SPARQL SELECT Queries</h3>
					<p>
						Validators that have the <code>rdf:type</code> <code>sh:SPARQLSelectValidator</code> must point at exactly one string representation of a SPARQL SELECT query via the property <code>sh:select</code>.
						The value of <code>sh:select</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
					</p>
					<p>
						The following example illustrates the definition of a constraint component based on a SPARQL SELECT query.
						It is a generalized variation of the SPARQL-based example constraint from the <a href="#example-sparql-constraint">section on SPARQL-based constraints</a>.
						That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
						Constraint components make it possible to generalize such scenarios, so that constants get <a>pre-bound</a> with <a>parameters</a>.
						This allows the query logic to be reused in multiple places, without having to write any new SPARQL.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingSELECT
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:context sh:PropertyConstraint ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:propertyValidator [
		a sh:SPARQLSelectValidator ;
		sh:message "Values must be literals with language \"{?lang}\"" ;
		sh:select """
			SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
			WHERE {
				$this $predicate ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
			}
			"""
	] .</pre>
					<p>
						Once a constraint component has been defined, its parameters can be used in the declared <span class="term">contexts</span>, as illustrated in the following example.
						The <code>sh:context</code> of the given constraint component includes <code>sh:PropertyConstraint</code> which means that the new parameter <code>ex:lang</code> can be used in values of <code>sh:property</code>.
						Furthermore, the SPARQL query can access the provided <code>sh:predicate</code> using the variable <code>$predicate</code>.
					</p>
					<pre class="example-shapes" title="Shape definition using ex:LanguageConstraintComponent">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:property [
		sh:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:property [
		sh:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
					<p>
						The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
						while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
						These details are specified via two property constraints that provide values for the <code>ex:lang</code> parameter required by the constraint component.
					</p>
					<p id="SPARQLSelectValidator-evaluation">
						A SPARQL-based SHACL validation engine executes the provided SPARQL query with the same <a>pre-bound variables</a>
						as outlined in the section for <a href="#sparql-constraints-prebound">SPARQL-based Constraints</a> (<code>$this</code> etc).
						Additionally, the value of each declared <span class="term">parameter</span> of the constraint component needs to be pre-bound for
						the variable derived by the <span class="term">local name</span> of the parameter's <code>sh:predicate</code>.
						For example, if a non-optional parameter declares <code>sh:predicate ex:lang</code> then the variable <code>$lang</code> needs to be pre-bound.
						The result set of the SELECT query is turned into validation results using the same rules as outlined in the section for <a href="#sparql-constraints-variables">SPARQL-based Constraints</a>.
						In addition to the result properties listed in that section, the property <code>sh:sourceConstraintComponent</code> MUST point at the
						IRI of the constraint component that has been evaluated.
						Furthermore, a <code>sh:SPARQLSelectValidator</code> may declare additional <a href="#sparql-constraints-annotations">annotation properties</a> via <code>sh:resultAnnotation</code>.
					</p>
				</section>
				<section id="SPARQLAskValidator">
					<h3>Validators based on SPARQL ASK Queries</h3>
					<p>
						Many constraint components are of the form in which all <a>value nodes</a> are tested individually against some boolean condition.
						Writing SELECT queries for these becomes burdensome, especially if a constraint component can be used in multiple contexts.
						SHACL provides an alternative, more compact syntax for validators based on ASK queries.
					</p>
					<p>
						Validators that have the <code>rdf:type</code> <code>sh:SPARQLAskValidator</code> must point at exactly one string representation of a SPARQL ASK query via the property <code>sh:ask</code>.
						The value of <code>sh:ask</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
						The ASK queries are expected to return <code>true</code> if a given <a>value node</a>
						(represented by the pre-bound variable <code>?value</code>) is valid.
					</p>
					<p>
						Prior to evaluation, a SHACL validation engine transforms the provided ASK query into a SELECT query using the following templates.
						The engine drops the ASK keyword, leaving only the fraction between the outermost <code>{...}</code> pair.
						This block then substitutes <code>...</code> in the template.
					</p>
					<p>Template for <code>sh:NodeConstraint</code> context:</p>
					<pre>
	SELECT $this
	WHERE {
		BIND ($this AS ?value) .
		FILTER NOT EXISTS ...
	}</pre>
					<p>Template for <code>sh:PropertyConstraint</code> context:</p>
					<pre>
	SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
	WHERE {
		$this $predicate ?value .
		FILTER NOT EXISTS ...
	}</pre>
					<p>Template for <code>sh:InversePropertyConstraint</code> context:</p>
					<pre>
	SELECT $this ($this AS ?object) $predicate (?value AS ?subject)
	WHERE {
		?value $predicate $this .
		FILTER NOT EXISTS ...
	}</pre>
					<p>
						The templates need to use a different variable than <code>?value</code> if the constraint component has a parameter that would cause <code>?value</code> to be a pre-bound variable.
					</p>
					<p>
						Once the corresponding template has been applied, the resulting SELECT query will be evaluated using the same approach as outlined <a href="#SPARQLSelectValidator-evaluation">above</a>.
						Actual SHACL implementations may of course use a different approach internally, as long as the results are equivalent to the described approach.
					</p>
					<p>
						The following example defines a constraint component using an ASK query.
						Note that the example represents the validator with an IRI node <code>ex:hasLang</code>
						so that it becomes easier to reuse the same validator for both contexts.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingASK
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:context sh:NodeConstraint, sh:PropertyConstraint ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:nodeValidator ex:hasLang ;
	sh:propertyValidator ex:hasLang .

ex:hasLang
	a sh:SPARQLAskValidator ;
	sh:message "Values must be literals with language \"{$lang}\"" ;
	sh:ask """
		ASK {
			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang))
		}
		""" .</pre>
					<p>
						Note that the validation condition implemented by an ASK query is "in the inverse direction" from its SELECT counter-part:
						ASK queries return <code>true</code> for valid value nodes, while SELECT queries return the invalid value nodes.
					</p>
					<p class="todo">
						TODO: The TopBraid SHACL API uses such ASK constraint declarations to install new SPARQL functions.
						Time permitting we could standardize that too, so that people can reuse the same business logic in the queries.
					</p>
				</section>
			</section>

			<section>
				<h3>Evaluation</h3>
				A constraint component is triggered for every <a>SHACL instance</a> of a context that defines all non-optional parameters.
			</section>
		</section>

		<section id="sparql-scopes">
			<h2>SPARQL-based Scopes (sh:scope)</h2>
			<p>
				SHACL provides facilities to define custom scopes.
				Similar to constraints, scopes may either be <a href="#SPARQLScope"><span class="term">SPARQL-based scopes</span></a> or
				<a href="#SPARQLScopeType"><span class="term">SPARQL-based scope types</span></a> in a higher-level vocabulary.
				All subjects of <code>sh:scope</code> triples must be IRIs.
			</p>
			<section id="SPARQLScope">
				<h3>Scopes using sh:SPARQLScope</h3>
				<p>
					SPARQL-based scopes must be <a>SHACL instances</a> of <code>sh:SPARQLScope</code>, which is a <a>SHACL subclass</a> of <code>sh:Scope</code>.
					The SPARQL queries linked to a <span class="term">scope</span> via <code>sh:select</code> must be of the query form <code>SELECT</code>.
					The SELECT queries must project to the result variable <code>?this</code>.
					The resulting scope consists of all distinct bindings for the variable <code>?this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This design makes sure that validation engines can validate whether a given shape applies to a given individual focus node.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based scope that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based scope example">
ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		a sh:SPARQLScope ;
		sh:select """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	sh:constraint ...</pre>
			</section>
			<section id="SPARQLScopeType">
				<h3>SPARQL-based Scope Types</h3>
				<p>
					The class <code>sh:ScopeType</code> can be used to define high-level vocabularies for scopes.
					Similar to constraint components, such scopes take <span class="term">parameters</span> that are interpreted when the scope is evaluated.
					The class <code>sh:SPARQLScopeType</code> is a <a>SHACL subclass</a> of <code>sh:ScopeType</code> for scope types that define a SPARQL SELECT query via the property <code>sh:select</code>.
					Similar to constraint components, the parameter values become <span class="term">pre-bound variables</span> in such SPARQL queries.
					The parameter values of such scopes must not be blank nodes.
					All parameters of scope types are expected to have <code>sh:maxCount 1</code>.
					Similar to constraint components, scope types may also have values for the property <a href="#labelTemplate"><code>sh:labelTemplate</code></a>.
				</p>
				<p>
					The following example defines a new SPARQL-based parameterizable scope class that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>$country</code> in the corresponding SPARQL query to determine the resulting focus nodes.
				</p>
				<pre class="example-shapes" title="Parameterized scope example">
ex:PeopleBornInCountryScope
	a sh:SPARQLScopeType ;
	rdfs:subClassOf sh:Scope ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:predicate ex:country ;
		sh:name "country" ;
		sh:description "The country that the focus nodes must be born in." ;
		sh:class ex:Country ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:select """
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .

ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		a ex:BornInCountryScope ;
		ex:country ex:USA ;
	] ;
	sh:constraint ...</pre>
				<p>
					The set of scope nodes produced by such a scope type consists of all bindings of the variable <code>?this</code> in the result set,
					when the SPARQL SELECT query has been executed with the pre-bound parameter values.
				</p>
			</section>
		</section>

		<section id="derivedValues">
			<h2>Derived Values Constraints</h2>
			<p>
				It is a common scenario that certain property values are derived from other values.
				For example, the area of a rectangle must be the product of width and height, or an uncle of a person is a male sibling of a parent.
				SHACL includes a constraint parameter <code>sh:derivedValues</code> that can be used with property and inverse property constraints to define such constraints.
			</p>
			<p>
				<span class="component-class">Constraint Component:</span> <code>sh:DerivedValuesConstraintComponent</code>
			</p>
			<p>
				<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>.
			</p>
			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>sh:derivedValues</code></td>
					<td><code>sh:ValuesDeriver</code></td>
					<td>An object providing instructions on how to derive the values</td>
				</tr>
			</table>
			<p>
				The values of <code>sh:derivedValues</code> must be <a>SHACL instances</a> of a <a>SHACL subclass</a> of <code>sh:ValuesDeriver</code>.
				<code>sh:SPARQLValuesDeriver</code> is the only <a>SHACL subclass</a> of <code>sh:ValuesDeriver</code> defined by SHACL.
				Each <code>sh:SPARQLValuesDeriver</code> must have exactly one value for the property <code>sh:select</code> that can be used to produce the values that the property is expected to have.
				The values of <code>sh:select</code> must be SPARQL SELECT queries that project into the variable <code>?value</code> only.
				These queries can access the current focus node via the variable <code>$this</code> and must produce bindings for the variable <code>?value</code> for all derived values.
			</p>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body">
					Let S be the set of nodes produces by the derived values template for the <span class="term">focus node</span>.
					A <span class="term">validation result</span> must be produced for every value of the given property <code>sh:predicate</code>
					that is not in S, and for every member of S that is not a property value.
					The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code>, and the missing or extra value as its <code>sh:object</code>.
					(The same definition applies in the inverse direction if <code>sh:derivedValues</code> is used in an inverse property constraint.)
				</div>
			</div>
			<p>
				The following example illustrates the use of <code>sh:derivedValues</code> to define a restriction
				so that the value of the property <code>ex:area</code> must be the product of the value of <code>ex:width</code> and <code>sh:height</code>.
			</p>
			<pre class="example-shapes" title="A property definition with derived values">
ex:RectangleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:area ;
		sh:datatype xsd:integer ;
		sh:derivedValues [
			a sh:SPARQLValuesDeriver ;
			sh:select """
				SELECT ?value
				WHERE {
					$this ex:width ?width .
					$this ex:height ?height .
					BIND (?width * ?height AS ?value) .
				}
				""" ;
		] ;
	] .</pre>
		</section>

		<section id="functions">
			<h2>SPARQL Functions</h2>
			<p>
				SHACL <dfn data-lt="function|SHACL function">functions</dfn> define operations that produce an RDF <a>node</a> based on zero or more <a>parameters</a> and an input RDF <a>graph</a> (or dataset).
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<section id="sparql-functions-syntax">
				<h3>Syntax of SPARQL Functions</h3>
				<p>
					Functions that encapsulate a SPARQL query must be <a>SHACL instances</a> of <code>sh:SPARQLFunction</code>, which is a <a>SHACL subclass</a> of the more general class <code>sh:Function</code>.
					Such functions must provide exactly one value for either <code>sh:ask</code> or <code>sh:select</code>, linking to a SPARQL query.
				</p>
				<p>
					The following example illustrates the definition of a function based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:SPARQLFunction ;
	rdfs:comment "Computes the sum of its two parameters ?op1 and ?op2." ;
	sh:parameter [
		sh:predicate ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:predicate ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:select """
		SELECT ($op1 + $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines with full SHACL support can install a new SPARQL function based on the SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>, as illustrated in the following SPARQL query.
				</p>
				<pre class="example-shapes" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject
WHERE {
	?subject ex:myProperty ?value .
	FILTER (ex:exampleFunction(?value, 2) = 42) .
}</pre>
				<p>
					The following sections introduce the properties that such functions may have.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The <a>parameters</a> of a function are linked to its <code>sh:Function</code> via the property <code>sh:parameter</code>.
					Each <a>parameter</a> must be a <a>SHACL instance</a> of <code>sh:Parameter</code>, but their <code>rdf:type</code> triple can be omitted.
				</p>
				<p>
					Each <code>sh:Parameter</code> must have exactly one <a>value</a> for the property <code>sh:predicate</code>.
					The <a>values</a> of <code>sh:predicate</code> must be <a>IRIs</a>, and follow the following restrictions:
				</p>
				<ul>
					<li>The <a>local name</a> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Parameter</code> for the same function that has a <code>sh:predicate</code> with the same <a>local name</a></li>
				</ul>
				<p id="parameters-ordering">
					<a>Parameters</a> are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function <a>parameters</a> is determined as follows:
				</p>
				<ol>
					<li><a>Parameters</a> are ordered in ascending order by the numeric values of <code>sh:order</code>.</li>
					<li><a>Parameters</a> that do not declare an <code>sh:order</code> are placed after those that have.</li>
					<li><a>Parameters</a> that do not declare an <code>sh:order</code> are ordered by the <a>local names</a> of their declared <code>sh:predicate</code>s.</li>
				</ol>
				<p>
					Each <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the <a>parameter</a> is not mandatory.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an <a>RDF term</a>.
				</p>
			</section>
			<section id="function-evaluation">
				<h3>Evaluation of Functions</h3>
				<p>
					<a>SHACL instances</a> of <code>sh:SPARQLFunction</code> must have exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>.
					The <a>values</a> of this property must be strings that can be parsed into SPARQL queries of type ASK (for <code>sh:ask</code>) or SELECT (for <code>sh:select</code>).
					SELECT queries must project exactly one result variable and SHOULD not use the <code>SELECT *</code> syntax.
					In the SPARQL query, the SPARQL processor needs to <a>pre-bind</a> variables based on the provided parameters of the function call.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the binding of the (single) result variable of the first row in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
					Also note that the result variable may be unbound, making the return value of the function <span class="term">undefined</span>.
				</p>
				<p>
					<em>Recursive use of functions is undefined:</em>
					If a SPARQL-based function contains calls to other functions so that the same function with the same combination of parameters would be visited twice
					then the result of the function call is undefined.
					An implementation may either return no result (unbound) or terminate the surrounding SPARQL query with an error.
				</p>
				<p>
					Some processors may ignore the specified SPARQL query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified SPARQL query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the SPARQL query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>

		<section id="entailment">
			<h2>Entailment</h2>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be activated on the <a>data graph</a>.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL <a>validation</a> engine to ensure that a given entailment is activated on the <a>data graph</a>.
				The <a>values</a> of <code>sh:entailment</code> must be <a>IRIs</a>, with common use cases covered by [[!sparql11-entailment]].
				<!--DK: we can be agnostic on the what the subject is-->
				<!--The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.-->
			</p>
			<p>
				SHACL <a>validation</a> engines are not required to support any entailment regimes.
				If an entailment regime is provided in the <a>data graph</a> which is not supported by the engine, the <a>validation</a> must produce a <a>failure</a>.
			</p>
		</section>

		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>

		<section id="hasShape" class="appendix">
			<h2>The Function sh:hasShape</h2>
			<div class="issue" data-number="131" title="sh:hasShape">
				The following definition is under discussion.
			</div>
			<p>
				SHACL implementations with full support of the SHACL SPARQL extension mechanism must implement
				a function <code>sh:hasShape</code>, which takes the following <a>parameters</a>:
			</p>
			<table class="term-table">
				<tr>
					<th style="min-width: 200px">Parameter</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>focusNode</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The focus node to validate.</td>
				</tr>
				<tr>
					<td><code>shape</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The shape to validate the focus node against.</td>
				</tr>
				<tr>
					<td><code>shapesGraph</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The IRI of the current <span class="term">shapes graph</span>.</td>
				</tr>
			</table>
			<p>
				An example call of this function is
			</p>
			<pre>
				<code>BIND (sh:hasShape(ex:JohnDoe, ex:PersonShape, $shapesGraph) AS ?hasShape)</code>
			</pre>
			<p>
				None of the <a>parameters</a> can be unbound.
				The result of the <code>sh:hasShape</code> function is either <code>true</code>, <code>false</code> or <span class="term">undefined</span>:
			</p>
			<ul>
				<li><code>true</code> if the <a>validation</a> of the <code>focusNode</code> against the given <code>shape</code> produces no <a>validation results</a> with severity <code>sh:Violation</code>.</li>
				<li><code>false</code> if the <a>validation</a> of the <code>focusNode</code> against the given <code>shape</code> produces at least one <a>validation result</a> with severity <code>sh:Violation</code>.</li>
				<li><span class="term">undefined</span> if during the execution a <a>failure</a> has been reported. This result indicates a <a>failure</a>.
				Implementations MAY for example use this to report infinite recursion.</li>
			</ul>
			<p>
				Note that any <a>validation results</a> produced inside of the <code>sh:hasShape</code> function are temporary, i.e. they are not added to the results graph of the surrounding <a>validation</a> process.
				However, some implementations may add those nested <a>validation results</a> as annotations to the surrounding <a>validation results</a>, via <a href="#results-detail"><code>sh:detail</code></a>.
			</p>
		</section>

		<section id="pre-binding" class="appendix">
			<h2>Pre-binding of Variables in SPARQL Queries</h2>
			<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
				The following definition of what pre-binding means has not been approved by the WG yet,
				and is work in progress.
			</p>
			<p>
				Some features of the SPARQL-based extension mechanism of SHACL rely on the concept of <dfn data-lt="pre-binding|pre-bind|pre-bound|pre-bound variables">pre-binding of variables</dfn>.
				Although variations of this concept are supported by several existing SPARQL implementations, there is no formal definition of pre-binding in the SPARQL 1.1 specifications.
				The goal of this section is to illustrate the effect of pre-binding to users and implementers.
				Note however that the following definition is not meant to serve as recommendation for an actual implementation strategy.
			</p>
			<p>
				<span class="term">Pre-binding</span> a variable with a value means that
				the SPARQL processor needs to evaluate all occurrences of variables with that same name
				(including occurrences in inner scopes and nested SELECT queries)
				so that they have the provided value.
				In other words, whenever a SPARQL processor evaluates a pre-bound variable, it must use the given value.
 			</p>
		</section>

		<section id="defaultValueType" class="appendix">
			<h2>Default value types (sh:defaultValueType)</h2>
			<p>
				Some SHACL properties such as <code>sh:property</code>, <code>sh:filterShape</code> and <code>sh:parameter</code> may have untyped <a>blank nodes</a> or <a>IRIs</a> as their <a>values</a>.
				If, for example, a <a>value</a> of <code>sh:property</code> is a <a>blank node</a> that does not have any <code>rdf:type</code>, then the assumption is that the <a>blank node</a> has <a>type</a> <code>sh:PropertyConstraint</code>.
				The SHACL system vocabulary includes some helper <a>triples</a> using the predicate <code>sh:defaultValueType</code> to specify the default <code>rdf:type</code> for certain properties.
				For example, the default value type of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
				SHACL includes a resource <code>sh:DefaultValueTypeRule</code> that encapsulates a SPARQL query via <code>sh:construct</code> that can be used for that purpose:
			</p>
			<pre class="algorithm">
CONSTRUCT {
	?node a ?defaultValueType .
}
WHERE {
	?predicate sh:defaultValueType ?defaultValueType .
	?anySubject ?predicate ?node .
	FILTER (NOT EXISTS { ?node a ?anyType }) .
}</pre>
		</section>

		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this specification, including members of the RDF Data Shapes Working Group.
				We especially thank the following:
			</p>
			<p>
				Arnaud Le Hors (chair),
				Jim Amsden,
				Iovka Boneva,
				Karen Coyle,
				Richard Cyganiak,
				Michel Dumontier,
				Holger Knublauch,
				Dimitris Kontokostas,
				Jose Labra,
				Peter Patel-Schneider,
				Eric Prud'hommeaux,
				Arthur Ryman (who also served as a co-editor until Feb 2016),
				Harold Solbrig,
				Simon Steyskal,
				Ted Thibodeau
			</p>
		</section>

	</body>
</html>
